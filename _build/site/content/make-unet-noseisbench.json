{"version":3,"kind":"Notebook","sha256":"d173cb95aec2724d1d9d6d9b6df3b0a84160558be8773b555fdc6fc21e755e6a","slug":"make-unet-noseisbench","location":"/notebooks/Amanda/make_unet_noseisbench.ipynb","dependencies":[],"frontmatter":{"title":"Making and training a U-net for seismic phase detection","content_includes_title":false,"kernelspec":{"name":"python3","display_name":"Python 3 (ipykernel)","language":"python"},"authors":[{"id":"Amanda M. Thomas, William Marfo, and Loïc Bachelot","name":"Amanda M. Thomas, William Marfo, and Loïc Bachelot"}],"keywords":["earthquake","catalog","ML","AI"],"numbering":{"title":{"offset":2}},"exports":[{"format":"ipynb","filename":"make_unet_noseisbench.ipynb","url":"/make_unet_noseisbenc-dedb26139a81a2af366359eb46f4f5b4.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n# from torchsummary import summary\n# from torchviz import make_dot\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom torchinfo import summary\nimport pandas as pd\nimport h5py","key":"Sw4jgNd4Tc"},{"type":"outputs","id":"4MFGzDdnaT5Jv_CggApuB","children":[],"key":"NxNynZFdPd"}],"key":"G2B0KM1xcw"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Build the U-net","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"Yqs2GVjq7P"}],"identifier":"build-the-u-net","label":"Build the U-net","html_id":"build-the-u-net","implicit":true,"key":"aBqVekQPou"}],"key":"VTOOOwnAtf"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Cell 2: U-Net Building Blocks\nclass ConvBlock(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size=3, padding=1):\n        super().__init__()\n        self.conv = nn.Sequential(\n            nn.Conv1d(in_channels, out_channels, kernel_size, padding=padding),\n            nn.ReLU(),\n            nn.Conv1d(out_channels, out_channels, kernel_size, padding=padding),\n            nn.ReLU()\n        )\n\n    def forward(self, x):\n        return self.conv(x)\n\nclass UNet1D(nn.Module):\n    def __init__(self, in_channels=3, out_channels=3, features=[16, 32, 64, 128]):\n        super().__init__()\n        \n        self.downs = nn.ModuleList()  # Encoder blocks (downsampling path)\n        self.ups = nn.ModuleList()    # Decoder blocks (upsampling path)\n    \n        # ----- Encoder: Downsampling Path -----\n        # Each ConvBlock halves the temporal resolution via pooling (done in forward),\n        # and increases the number of feature channels.\n        for feat in features:\n            self.downs.append(ConvBlock(in_channels, feat))  # ConvBlock: Conv + ReLU + Conv + ReLU\n            in_channels = feat  # Update in_channels for the next block\n    \n        # ----- Bottleneck -----\n        # Deepest layer in the U-Net, connects encoder and decoder\n        self.bottleneck = ConvBlock(features[-1], features[-1]*2)\n    \n        # ----- Decoder: Upsampling Path -----\n        # Reverse features list for symmetrical decoder\n        rev_feats = features[::-1]\n        for feat in rev_feats:\n            # First upsample (via transposed convolution)\n            self.ups.append(\n                nn.ConvTranspose1d(feat*2, feat, kernel_size=2, stride=2)\n            )\n            # Then apply ConvBlock: input has double channels due to skip connection\n            self.ups.append(ConvBlock(feat*2, feat))\n    \n        # ----- Final Output Convolution -----\n        # 1x1 convolution to map to desired output channels (e.g., P, S, noise)\n        self.final_conv = nn.Conv1d(features[0], out_channels, kernel_size=1)\n\n    def forward(self, x):\n        skip_connections = []\n\n        for down in self.downs:\n            x = down(x)\n            skip_connections.append(x)\n            x = F.max_pool1d(x, kernel_size=2)\n\n        x = self.bottleneck(x)\n        skip_connections = skip_connections[::-1]\n\n        for idx in range(0, len(self.ups), 2):\n            x = self.ups[idx](x)\n            skip_conn = skip_connections[idx//2]\n            if x.shape[-1] != skip_conn.shape[-1]:\n                x = F.pad(x, (0, skip_conn.shape[-1] - x.shape[-1]))\n            x = torch.cat((skip_conn, x), dim=1)\n            x = self.ups[idx+1](x)\n        x = self.final_conv(x)\n        return F.softmax(x, dim=1)","key":"je0fgNF0ML"},{"type":"outputs","id":"EsM967Spy5hO1E5sbUhg9","children":[],"key":"ha58wXOiao"}],"key":"jAJ22deDMf"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"model = UNet1D()","key":"uENBsqSLyJ"},{"type":"outputs","id":"Ps5Mx48J-CccJnr6Ynkkh","children":[],"key":"mHda9tCU2k"}],"key":"N2wLmc8xR0"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"summary(model, input_size=(1, 3, 3000))","key":"s7UBPWTxWD"},{"type":"outputs","id":"Zi1GdN6vcLZtI96pjKP8z","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":4,"metadata":{},"data":{"text/plain":{"content":"==========================================================================================\nLayer (type:depth-idx)                   Output Shape              Param #\n==========================================================================================\nUNet1D                                   [1, 3, 3000]              --\n├─ModuleList: 1-1                        --                        --\n│    └─ConvBlock: 2-1                    [1, 16, 3000]             --\n│    │    └─Sequential: 3-1              [1, 16, 3000]             944\n│    └─ConvBlock: 2-2                    [1, 32, 1500]             --\n│    │    └─Sequential: 3-2              [1, 32, 1500]             4,672\n│    └─ConvBlock: 2-3                    [1, 64, 750]              --\n│    │    └─Sequential: 3-3              [1, 64, 750]              18,560\n│    └─ConvBlock: 2-4                    [1, 128, 375]             --\n│    │    └─Sequential: 3-4              [1, 128, 375]             73,984\n├─ConvBlock: 1-2                         [1, 256, 187]             --\n│    └─Sequential: 2-5                   [1, 256, 187]             --\n│    │    └─Conv1d: 3-5                  [1, 256, 187]             98,560\n│    │    └─ReLU: 3-6                    [1, 256, 187]             --\n│    │    └─Conv1d: 3-7                  [1, 256, 187]             196,864\n│    │    └─ReLU: 3-8                    [1, 256, 187]             --\n├─ModuleList: 1-3                        --                        --\n│    └─ConvTranspose1d: 2-6              [1, 128, 374]             65,664\n│    └─ConvBlock: 2-7                    [1, 128, 375]             --\n│    │    └─Sequential: 3-9              [1, 128, 375]             147,712\n│    └─ConvTranspose1d: 2-8              [1, 64, 750]              16,448\n│    └─ConvBlock: 2-9                    [1, 64, 750]              --\n│    │    └─Sequential: 3-10             [1, 64, 750]              36,992\n│    └─ConvTranspose1d: 2-10             [1, 32, 1500]             4,128\n│    └─ConvBlock: 2-11                   [1, 32, 1500]             --\n│    │    └─Sequential: 3-11             [1, 32, 1500]             9,280\n│    └─ConvTranspose1d: 2-12             [1, 16, 3000]             1,040\n│    └─ConvBlock: 2-13                   [1, 16, 3000]             --\n│    │    └─Sequential: 3-12             [1, 16, 3000]             2,336\n├─Conv1d: 1-4                            [1, 3, 3000]              51\n==========================================================================================\nTotal params: 677,235\nTrainable params: 677,235\nNon-trainable params: 0\nTotal mult-adds (Units.MEGABYTES): 257.17\n==========================================================================================\nInput size (MB): 0.04\nForward/backward pass size (MB): 8.52\nParams size (MB): 2.71\nEstimated Total Size (MB): 11.26\n==========================================================================================","content_type":"text/plain"}}},"children":[],"key":"apeOnXhvAU"}],"key":"tAeTtYX5Wl"}],"key":"FytqDRkD99"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"sample = test_generator[np.random.randint(len(test_generator))]\n\nfig = plt.figure(figsize=(15, 10))\naxs = fig.subplots(3, 1, sharex=True, gridspec_kw={\"hspace\": 0, \"height_ratios\": [3, 1, 1]})\naxs[0].plot(sample[\"X\"].T)\naxs[1].plot(sample[\"y\"].T)\n\nmodel.eval()  # close the model for evaluation\n\nwith torch.no_grad():\n    pred = model(torch.tensor(sample[\"X\"], device=device).unsqueeze(0))  # Add a fake batch dimension\n    pred = pred[0].cpu().numpy()\n\naxs[2].plot(pred.T)","key":"qNbKiag3kZ"},{"type":"outputs","id":"VNuJbCVexOvGkiy6W-suh","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"845aaa7aacbe20a62a0eddf063770b46","path":"/845aaa7aacbe20a62a0eddf063770b46.png"},"text/plain":{"content":"<Figure size 1500x1000 with 3 Axes>","content_type":"text/plain"}}},"children":[],"key":"YqTMlule9i"}],"key":"NRNKFbiVC1"}],"key":"WzwzbFTq92"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"torch.save(model.state_dict(), \"model_weights.pt\")\ntorch.save(model, \"fullmodel_with_architacture.pt\")","key":"F46GIRyGky"},{"type":"outputs","id":"gmkEi38QTMaPZ-DdOOygD","children":[],"key":"OBwoh5Pg2m"}],"key":"UoaLhynhDi"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Load model for ref","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"iuq0dnW6f7"}],"identifier":"load-model-for-ref","label":"Load model for ref","html_id":"load-model-for-ref","implicit":true,"key":"VPtBTXKDyw"}],"key":"ATAHhTHKPS"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"model = UNet1D()\nmodel.load_state_dict(torch.load(\"model_weights.pt\"))\nmodel.eval()  # set to eval mode for inference","key":"cvCnsCrt1B"},{"type":"outputs","id":"fGYqgMStDcGR_RXRjUYh9","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":18,"metadata":{},"data":{"text/plain":{"content":"UNet1D(\n  (downs): ModuleList(\n    (0): ConvBlock(\n      (conv): Sequential(\n        (0): Conv1d(3, 16, kernel_size=(3,), stride=(1,), padding=(1,))\n        (1): ReLU()\n        (2): Conv1d(16, 16, kernel_size=(3,), stride=(1,), padding=(1,))\n        (3): ReLU()\n      )\n    )\n    (1): ConvBlock(\n      (conv): Sequential(\n        (0): Conv1d(16, 32, kernel_size=(3,), stride=(1,), padding=(1,))\n        (1): ReLU()\n        (2): Conv1d(32, 32, kernel_size=(3,), stride=(1,), padding=(1,))\n        (3): ReLU()\n      )\n    )\n    (2): ConvBlock(\n      (conv): Sequential(\n        (0): Conv1d(32, 64, kernel_size=(3,), stride=(1,), padding=(1,))\n        (1): ReLU()\n        (2): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,))\n        (3): ReLU()\n      )\n    )\n    (3): ConvBlock(\n      (conv): Sequential(\n        (0): Conv1d(64, 128, kernel_size=(3,), stride=(1,), padding=(1,))\n        (1): ReLU()\n        (2): Conv1d(128, 128, kernel_size=(3,), stride=(1,), padding=(1,))\n        (3): ReLU()\n      )\n    )\n  )\n  (ups): ModuleList(\n    (0): ConvTranspose1d(256, 128, kernel_size=(2,), stride=(2,))\n    (1): ConvBlock(\n      (conv): Sequential(\n        (0): Conv1d(256, 128, kernel_size=(3,), stride=(1,), padding=(1,))\n        (1): ReLU()\n        (2): Conv1d(128, 128, kernel_size=(3,), stride=(1,), padding=(1,))\n        (3): ReLU()\n      )\n    )\n    (2): ConvTranspose1d(128, 64, kernel_size=(2,), stride=(2,))\n    (3): ConvBlock(\n      (conv): Sequential(\n        (0): Conv1d(128, 64, kernel_size=(3,), stride=(1,), padding=(1,))\n        (1): ReLU()\n        (2): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,))\n        (3): ReLU()\n      )\n    )\n    (4): ConvTranspose1d(64, 32, kernel_size=(2,), stride=(2,))\n    (5): ConvBlock(\n      (conv): Sequential(\n        (0): Conv1d(64, 32, kernel_size=(3,), stride=(1,), padding=(1,))\n        (1): ReLU()\n        (2): Conv1d(32, 32, kernel_size=(3,), stride=(1,), padding=(1,))\n        (3): ReLU()\n      )\n    )\n    (6): ConvTranspose1d(32, 16, kernel_size=(2,), stride=(2,))\n    (7): ConvBlock(\n      (conv): Sequential(\n        (0): Conv1d(32, 16, kernel_size=(3,), stride=(1,), padding=(1,))\n        (1): ReLU()\n        (2): Conv1d(16, 16, kernel_size=(3,), stride=(1,), padding=(1,))\n        (3): ReLU()\n      )\n    )\n  )\n  (bottleneck): ConvBlock(\n    (conv): Sequential(\n      (0): Conv1d(128, 256, kernel_size=(3,), stride=(1,), padding=(1,))\n      (1): ReLU()\n      (2): Conv1d(256, 256, kernel_size=(3,), stride=(1,), padding=(1,))\n      (3): ReLU()\n    )\n  )\n  (final_conv): Conv1d(16, 3, kernel_size=(1,), stride=(1,))\n)","content_type":"text/plain"}}},"children":[],"key":"j77bbyrzhN"}],"key":"mJLHakF7DP"}],"key":"MPqMk0OGxO"}],"key":"rtxgMF31NZ"},"references":{"cite":{"order":[],"data":{}}}}