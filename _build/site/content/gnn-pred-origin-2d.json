{"version":3,"kind":"Notebook","sha256":"73bab339ff5263915eabe203bc99fc25b5fa5b2e2665a4b206394bf9c9e82d86","slug":"gnn-pred-origin-2d","location":"/notebooks/Loic/GNN/other versions/GNN_pred_origin_2d.ipynb","dependencies":[],"frontmatter":{"title":"Training a GNN: node regression short signal and edges just 1 distance","content_includes_title":false,"kernelspec":{"name":"conda-env-pangeo_torch-py","display_name":"Python [conda env:pangeo_torch]","language":"python"},"authors":[{"id":"Amanda M. Thomas, William Marfo, and Loïc Bachelot","name":"Amanda M. Thomas, William Marfo, and Loïc Bachelot"}],"keywords":["earthquake","catalog","ML","AI"],"numbering":{"title":{"offset":4}},"exports":[{"format":"ipynb","filename":"GNN_pred_origin_2d.ipynb","url":"/GNN_pred_origin_2d-e4fccaf68bf180873f130bb4a9f34b62.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Parameters of simualation:","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"kneboDTAHJ"}],"key":"hryTEhcE51"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":4,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Domain size = 6*6","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"pTlaNi9cYk"}],"key":"FqPINgOiro"}],"key":"XX9IUCzMuK"},{"type":"listItem","spread":true,"position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"velocity = .5","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"gmFw52MHOa"}],"key":"U1bI2gSuZ1"}],"key":"NqPmPUSUBP"},{"type":"listItem","spread":true,"position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"signal size = 20","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"hDKKKP2Bf6"}],"key":"wqZlkE5qSL"}],"key":"WvofpZgqNw"},{"type":"listItem","spread":true,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"number station = 10-15","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"qo8u1GzizL"}],"key":"D2aS78794w"}],"key":"MOs452YXbB"}],"key":"QZHCvzYnS2"}],"key":"RoIHb5cUs8"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import pickle\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom torch_geometric.data import Data\nimport torch\nimport torch_geometric\nfrom torch_geometric.transforms import KNNGraph\nfrom torch_geometric.data import InMemoryDataset, Data\nfrom torch.nn import Linear, Parameter, LeakyReLU, Conv2d, MaxPool1d\nfrom torch_geometric.nn import GCNConv, MessagePassing, MLP, GATv2Conv, global_mean_pool, GlobalAttention\nfrom scipy.spatial import distance\nfrom torch_geometric.utils import add_self_loops, degree\nfrom tqdm import tqdm\nfrom torch import nn","visibility":"show","key":"daqyb8GsdE"},{"type":"outputs","id":"iI-NIEr_2G35NTxRNycaB","children":[],"visibility":"show","key":"zWTgfGaIr4"}],"visibility":"show","key":"kKbsQTfo2v"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"def visualize_graph_torch(g, color, pred=False):\n    fig, ax = plt.subplots(figsize=(6, 6))\n\n    # Plot edges\n    for edge in g.edge_index.T:\n        ax.plot(\n            [g.pos[edge[0]][0], g.pos[edge[1]][0]],\n            [g.pos[edge[0]][1], g.pos[edge[1]][1]],\n            color='blue', linewidth=1\n        )\n\n    # Plot nodes with color\n    scatter = ax.scatter(\n        x=g.pos.T[0],\n        y=g.pos.T[1],\n        alpha=1,\n        c=g[color][:, 0],\n        s=150\n    )\n\n    # Add color legend\n    legend1 = ax.legend(*scatter.legend_elements(), loc='center left', bbox_to_anchor=(1, 0.5))\n    ax.add_artist(legend1)\n\n    # Plot origin as a red cross (if present)\n    if hasattr(g, 'y') and g.y[0].numel() == 2:\n        ax.plot(g.y[0][0], g.y[0][1], 'rx', markersize=12, markeredgewidth=3, label='Origin')\n        ax.legend()\n        \n    if pred == True:\n        if hasattr(g, 'pred') and g.pred[0].numel() == 2:\n            ax.plot(g.pred[0][0], g.pred[0][1], 'bx', markersize=12, markeredgewidth=3, label='Prediction')\n            ax.legend()\n\n    plt.show()","visibility":"show","key":"RuzQshPnGX"},{"type":"outputs","id":"_IVKrjU7pN_v5aSbE-k4V","children":[],"visibility":"show","key":"SwhomDzVEF"}],"visibility":"show","key":"WyXTpf3P6W"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"def plot_signals_subplots_by_distance(data, velocity=0.5, sampling_rate=1.0, title=\"Signals by distance to origin\"):\n    \"\"\"\n    Plot each station's signal in its own subplot, ordered by distance to origin,\n    with vertical lines showing the arrival time of the sine wave.\n\n    Args:\n        data (Data): PyG Data object with:\n            - pos: [num_nodes, 2]\n            - signal: [num_nodes, SIGNAL_SIZE]\n            - y: [1, 2] or [2]\n        velocity (float): wave propagation speed (units/sec)\n        sampling_rate (float): samples per unit (Hz)\n        title (str): Figure title\n    \"\"\"\n    pos = data.pos.cpu().numpy()\n    signals = data.signal.cpu().numpy()\n    origin = data.y.squeeze().cpu().numpy()\n\n    num_nodes = pos.shape[0]\n\n    # Compute distances and arrival times\n    distances = np.array([distance.euclidean(origin, pos[i].tolist()) for i in range(num_nodes)])\n    arrival_samples = (distances / velocity * sampling_rate).astype(int)\n    sort_idx = np.argsort(distances)\n\n    # Plot\n    fig, axs = plt.subplots(num_nodes, 1, figsize=(10, 2 * num_nodes), sharex=True)\n\n    for i, idx in enumerate(sort_idx):\n        ax = axs[i]\n        signal = signals[idx]\n\n        ax.plot(np.arange(len(signal)), signal, color='black', linewidth=1)\n        ax.axvline(arrival_samples[idx], color='red', linestyle='--', linewidth=1, label='arrival')\n        ax.set_ylabel(f\"{distances[idx]:.2f}\", rotation=0, labelpad=25)\n        ax.grid(True, linestyle='--', alpha=0.3)\n\n    axs[-1].set_xlabel(\"Time (samples)\")\n    fig.suptitle(title, fontsize=14)\n    plt.tight_layout(rect=[0, 0, 1, 0.98])\n    plt.show()","key":"TolQ3i94q7"},{"type":"outputs","id":"iFv1jjlArmEMrltd0eHvl","children":[],"key":"mqiEdsqbpg"}],"key":"b0KjOul69s"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"SIGNAL_SIZE = 20\nNB_GRAPHS = 1000","visibility":"show","key":"n7iGMgYFLH"},{"type":"outputs","id":"mHhKZxjLnassswWNuS8it","children":[],"visibility":"show","key":"xaWlN6OLDm"}],"visibility":"show","key":"sP1rbCMtYX"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"def add_edge_weight(g):\n    edge_weight = []\n    for edge in g.edge_index.T:\n        edge_weight.append(1/(distance.euclidean((g.pos[edge[0]][0], g.pos[edge[0]][1]), (g.pos[edge[1]][0], g.pos[edge[1]][1]))+1))\n    g.edge_weight = torch.tensor(np.array(edge_weight)).type(torch.FloatTensor)\n    return g","visibility":"show","key":"MVDOlHQsCy"},{"type":"outputs","id":"cPCsLo_NBS5-D9u3yI_4K","children":[],"visibility":"show","key":"s2PGoteT2G"}],"visibility":"show","key":"xjI5EGvybS"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class SinOriginDataset(InMemoryDataset):\n    \"\"\"\n    Synthetic dataset for GNN training. Each graph has:\n    - Random 2D node positions.\n    - Node features as sine signals based on distance to a hidden origin.\n    - A target: the origin used to generate signals (same for all nodes in a graph).\n    \"\"\"\n\n    def __init__(self, root, transform=None, pre_transform=None, nb_graph=10):\n        self.nb_graph = nb_graph\n        super(SinOriginDataset, self).__init__(root, transform, pre_transform)\n        self.data, self.slices = torch.load(self.processed_paths[0], weights_only=False)\n\n    @property\n    def raw_file_names(self):\n        return 0  # No raw files needed\n\n    @property\n    def processed_file_names(self):\n        return 'data.pt'\n\n    def process(self):\n        data_list = []\n        # Configurable parameters\n        frequency = 1.0         # Hz\n        velocity = 0.5          # units/sec\n        sampling_rate = 1.0     # samples/unit\n        noise_std = 0.1         # noise standard deviation\n        base_sine_wave = np.sin(np.arange(SIGNAL_SIZE))\n        for _ in range(self.nb_graph):\n            # Random number of nodes between 5 and 15\n            nb_nodes = np.random.randint(10, 15)\n\n            # Random 2D positions for nodes\n            pos = torch.tensor(np.random.uniform(0, 6, size=(nb_nodes, 2)), dtype=torch.float)\n\n            # Select a random origin point (the target)\n            origin = np.random.randint(0, 6, size=2)\n            origin_tensor = torch.tensor(origin, dtype=torch.float)\n\n            # Generate delayed sine signals\n            signal_list = []\n\n            for i in range(nb_nodes):\n                dist = distance.euclidean(origin, pos[i].tolist())\n                delay = dist / velocity\n                delay_samples = int(delay * sampling_rate)\n\n                # Base waveform\n                waveform = np.random.normal(0, noise_std, size=SIGNAL_SIZE)\n\n                if delay_samples < SIGNAL_SIZE:\n                    insert_length = SIGNAL_SIZE - delay_samples\n                    waveform[delay_samples:] += base_sine_wave[:insert_length]\n\n                signal_list.append(waveform)\n\n            # Convert signal list to tensor\n            signal = torch.tensor(np.array(signal_list), dtype=torch.float32).reshape(nb_nodes, SIGNAL_SIZE)\n\n            # Construct PyG Data object\n            g = Data(pos=pos, signal=signal, y=origin_tensor.unsqueeze(0))  # y shape (1, 2)\n\n            data_list.append(g)\n\n        # Optional transformations\n        if self.pre_transform is not None:\n            data_list = [self.pre_transform(data) for data in data_list]\n            data_list = [add_edge_weight(data) for data in data_list]\n\n        # Save processed data\n        data, slices = self.collate(data_list)\n        torch.save((data, slices), self.processed_paths[0])","visibility":"show","key":"K3SjWxKC0A"},{"type":"outputs","id":"FBb2613Gi5VG1guYPlE8z","children":[],"visibility":"show","key":"Eq7amuaZya"}],"visibility":"show","key":"fIMfKEytsz"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"raw_dataset = SinOriginDataset(root=\"./sin_train\", pre_transform=KNNGraph(k=5, loop=False, force_undirected=True), \n                       nb_graph=NB_GRAPHS)\nraw_dataset","visibility":"show","key":"DGlL1nzi4B"},{"type":"outputs","id":"9VT50wanm2uS5-pgj4eFs","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":7,"metadata":{},"data":{"text/plain":{"content":"SinOriginDataset(1000)","content_type":"text/plain"}}},"children":[],"key":"fl2L78SAgk"}],"visibility":"show","key":"ka7FRV1zbp"}],"visibility":"show","key":"BxOMn35UI1"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = raw_dataset[0]\ndata","visibility":"show","key":"h6P9Kn5ysl"},{"type":"outputs","id":"Xfph2AQKuQG7Hiyk44DxA","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":8,"metadata":{},"data":{"text/plain":{"content":"Data(y=[1, 2], pos=[13, 2], signal=[13, 20], edge_index=[2, 74], edge_weight=[74])","content_type":"text/plain"}}},"children":[],"key":"HEDILxy0hM"}],"visibility":"show","key":"fssSvHolY7"}],"visibility":"show","key":"Xcymf4FGDa"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"visualize_graph_torch(data, color='signal')","visibility":"show","key":"BrfBLBQUGc"},{"type":"outputs","id":"IRLjwW_n1nwlvD4r9PH0o","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"0481bb0d92fd8a95c60502e19b70d2c1","path":"/0481bb0d92fd8a95c60502e19b70d2c1.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"jbcr0HRt2L"}],"visibility":"show","key":"xII7ZKNge1"}],"visibility":"show","key":"Va1wdkTCEj"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"plot_signals_subplots_by_distance(data)","key":"vE3Rysy00s"},{"type":"outputs","id":"YEVNer6awBu3QPbLcNzkF","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"a2d43668716c490a9e9b7758abec0722","path":"/a2d43668716c490a9e9b7758abec0722.png"},"text/plain":{"content":"<Figure size 1000x2600 with 13 Axes>","content_type":"text/plain"}}},"children":[],"key":"F1hzbFxGji"}],"key":"OLnQPBfLuq"}],"key":"pWWmUK1EQp"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Preprocessing","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"YH9tE3lyRl"}],"identifier":"preprocessing","label":"Preprocessing","html_id":"preprocessing","implicit":true,"key":"wsh0RRgW0z"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Normalization of output step, input is already -1 to 1","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"TZ52nEmQ7C"}],"key":"NUctqPVgYr"}],"key":"MCuKk9K0G7"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"class NormalizeTargetsWrapper(torch.utils.data.Dataset):\n    \"\"\"\n    Wraps a PyG dataset to normalize `y` from [min_val, max_val] → [-1, 1].\n    \"\"\"\n    def __init__(self, dataset, min_val, max_val):\n        self.dataset = dataset\n        self.min_val = min_val\n        self.max_val = max_val\n\n    def __len__(self):\n        return len(self.dataset)\n\n    def __getitem__(self, idx):\n        data = self.dataset[idx].clone()\n        # scale from [min, max] to [-1, 1]\n        data.y = 2 * (data.y - self.min_val) / (self.max_val - self.min_val) - 1\n        return data\n\n    def denormalize(self, norm_y):\n        # scale back from [-1, 1] to [min, max]\n        return 0.5 * (norm_y + 1) * (self.max_val - self.min_val) + self.min_val","key":"U2A8MRQoC5"},{"type":"outputs","id":"yuxpq-0pNBM2vp5KxYQh7","children":[],"key":"jJ1IkUMgkC"}],"key":"ABn27tZle6"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"normalized_dataset = NormalizeTargetsWrapper(raw_dataset, min_val=0, max_val=6)","key":"PWpE84JX9v"},{"type":"outputs","id":"_2eE2xoQ-w5-81LbU0hng","children":[],"key":"Eho6GQfozW"}],"key":"p4cQccfKxP"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Build the GNN","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"UxS0hpUfEw"}],"identifier":"build-the-gnn","label":"Build the GNN","html_id":"build-the-gnn","implicit":true,"key":"lvZodAXQFU"}],"key":"j0hMWD7WKE"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class MLPNet(torch.nn.Module):\n    \"\"\"\n    GNN model with MLP → 2x GATv2Conv → MLP for graph-level origin prediction.\n\n    Args:\n        channels_x (int): Positional input features per node.\n        channels_y (int): Signal features per node.\n        hidden_channels (int): Hidden dimension.\n        dropout (float): Dropout probability.\n        self_loops (bool): Whether to add self-loops to GATv2Conv.\n\n    Output:\n        Tensor of shape (batch_size, 2), normalized origin coordinates (in [-1, 1]).\n    \"\"\"\n    def __init__(self, channels_x, channels_y, hidden_channels=128, dropout=0.3, self_loops=True):\n        super(MLPNet, self).__init__()\n        torch.manual_seed(1234)\n\n        self.mlp_in = MLP([channels_x + channels_y, 64, hidden_channels])\n\n        self.conv1 = GATv2Conv(\n            in_channels=hidden_channels,\n            out_channels=hidden_channels,\n            heads=2,\n            edge_dim=1,\n            add_self_loops=self_loops,\n            concat=True\n        )\n\n        self.conv2 = GATv2Conv(\n            in_channels=hidden_channels * 2,  # output of conv1 with 2 heads\n            out_channels=hidden_channels,\n            heads=2,\n            edge_dim=1,\n            add_self_loops=self_loops,\n            concat=True\n        )\n\n        self.mlp_out = MLP([hidden_channels * 2, 64], act=nn.LeakyReLU(), dropout=dropout)\n\n        self.att_pool = GlobalAttention(\n            gate_nn=torch.nn.Sequential(\n                nn.Linear(64, 32),\n                nn.ReLU(),\n                nn.Linear(32, 1)\n            )\n        )\n\n        self.out_linear = Linear(64, 2)\n        \n    def forward(self, pos, signal, edge_index, edge_weight, batch=None):\n        x = torch.cat([pos, signal], dim=-1)\n        x = self.mlp_in(x)\n        x = self.conv1(x, edge_index, edge_weight)\n        # x = self.conv2(x, edge_index, edge_weight)\n        x = self.mlp_out(x)\n\n        if batch is None:\n            batch = torch.zeros(x.size(0), dtype=torch.long, device=x.device)\n\n        graph_repr = self.att_pool(x, batch)\n        return self.out_linear(graph_repr).tanh()","visibility":"show","key":"eFWcnwZev5"},{"type":"outputs","id":"KfDYu7jZAhRgNbS1MhAay","children":[],"visibility":"show","key":"XplD4rskID"}],"visibility":"show","key":"V3Yc1lWDvF"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"training","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"mFYm746cbT"}],"identifier":"training","label":"training","html_id":"training","implicit":true,"key":"WLa2BXK1R9"}],"key":"pgpTuREOh4"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"from torch_geometric.loader import DataLoader\nfrom sklearn.model_selection import train_test_split\n\ntrain_dataset, val_dataset = train_test_split(normalized_dataset, train_size=0.5, random_state=42)\nval_dataset, test_dataset = train_test_split(val_dataset, train_size=0.8, random_state=42)\n\ntrain_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)\nval_loader = DataLoader(val_dataset, batch_size=64, shuffle=False)\ntest_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)\n\n\nprint(f\"nb graph train ds= {len(train_dataset)}, nb graph val ds= {len(val_dataset)}, nb graph test ds= {len(test_dataset)}\")","visibility":"show","key":"A7vbwxqaC8"},{"type":"outputs","id":"kiAZG1HyU29dofKLNuE-y","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"nb graph train ds= 500, nb graph val ds= 400, nb graph test ds= 100\n"},"children":[],"key":"hhVPl8p7Tf"}],"visibility":"show","key":"BXj5GRVNLg"}],"visibility":"show","key":"pFfxVwePPx"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = train_dataset[0]\ndata","visibility":"show","key":"M4sLuHvahS"},{"type":"outputs","id":"G1TjoPbWamjN7EnAvBBnF","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":16,"metadata":{},"data":{"text/plain":{"content":"Data(y=[1, 2], pos=[11, 2], signal=[11, 20], edge_index=[2, 74], edge_weight=[74])","content_type":"text/plain"}}},"children":[],"key":"GyfkkceGQM"}],"visibility":"show","key":"xnF1VNTtLF"}],"visibility":"show","key":"uOxblnT7SU"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"for batch in train_loader:\n    print(batch.y.shape)  # Should be [batch_size, 2]\n    break","key":"MsayMoOlK0"},{"type":"outputs","id":"53DkX9Vr27apo9KzquC3V","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"torch.Size([64, 2])\n"},"children":[],"key":"hKu5QL7DPA"}],"key":"QOxap98i5y"}],"key":"W6GEUYANIu"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class EarlyStopper:\n    \"\"\"\n    A class for early stopping the training process when the validation loss stops improving.\n    \"\"\"\n    def __init__(self, patience=1, min_delta=0):\n        self.patience = patience\n        self.min_delta = min_delta\n        self.counter = 0\n        self.min_validation_loss = np.inf\n\n    def early_stop(self, validation_loss):\n        if validation_loss < self.min_validation_loss:\n            self.min_validation_loss = validation_loss\n            self.counter = 0\n        elif validation_loss > (self.min_validation_loss + self.min_delta):\n            self.counter += 1\n            if self.counter >= self.patience:\n                return True\n        return False\n\n\ndef train(dataloader, device):\n    model.train()\n    mean_loss = 0\n    for data in dataloader:\n        data = data.to(device)\n        optimizer.zero_grad()\n\n        # Forward pass\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)  # → shape [num_graphs, 2]\n\n        # Check shape of target\n        assert data.y.shape == pred.shape, f\"Expected y shape {pred.shape}, got {data.y.shape}\"\n\n        loss = criterion(pred, data.y)\n        loss.backward()\n        optimizer.step()\n        mean_loss += loss.item()\n    return mean_loss / len(dataloader)\n\n\n@torch.no_grad()\ndef validation(dataloader, device):\n    model.eval()\n    total_loss = 0\n    for data in dataloader:\n        data = data.to(device)\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)\n        loss = criterion(pred, data.y)\n        total_loss += loss.item()\n    return total_loss / len(dataloader)","visibility":"show","key":"KSA4g9Feh2"},{"type":"outputs","id":"mAmHBYqLcg9ti1n6xfUkL","children":[],"visibility":"show","key":"FUlDhtq5GD"}],"visibility":"show","key":"C1EIVinzKX"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":4,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"set training parameters","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"JqaBHL8XE0"}],"identifier":"set-training-parameters","label":"set training parameters","html_id":"set-training-parameters","implicit":true,"key":"SkXdl2PGWu"}],"key":"sVFgPASN64"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n\nmodel = MLPNet(data.pos.shape[1], data.signal.shape[1], hidden_channels=64)\n\ncriterion = torch.nn.MSELoss()  # Define loss criterion.\noptimizer = torch.optim.Adam(model.parameters(), lr=0.0001)  # Define optimizer.\nearly_stopper = EarlyStopper(patience=20, min_delta=0.0)\nprint(device)","visibility":"show","key":"DVxjstygTf"},{"type":"outputs","id":"Gtmg56YtPHymzXXOBBtdk","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"cpu\n"},"children":[],"key":"rsUxKYjOsh"},{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"C:\\Users\\loicb\\miniconda3\\envs\\pangeo_torch\\Lib\\site-packages\\torch_geometric\\deprecation.py:26: UserWarning: 'nn.glob.GlobalAttention' is deprecated, use 'nn.aggr.AttentionalAggregation' instead\n  warnings.warn(out)\n"},"children":[],"key":"JYzK6JY4Cy"}],"visibility":"show","key":"VOKyUF8kIW"}],"visibility":"show","key":"EAtlzFwfEl"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"model","key":"w87MoYZsBh"},{"type":"outputs","id":"Bm_Fp4uiTdZ2JZOdepZC8","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":20,"metadata":{},"data":{"text/plain":{"content":"MLPNet(\n  (mlp_in): MLP(22, 64, 64)\n  (conv1): GATv2Conv(64, 64, heads=2)\n  (conv2): GATv2Conv(128, 64, heads=2)\n  (mlp_out): MLP(128, 64)\n  (att_pool): GlobalAttention(gate_nn=Sequential(\n    (0): Linear(in_features=64, out_features=32, bias=True)\n    (1): ReLU()\n    (2): Linear(in_features=32, out_features=1, bias=True)\n  ), nn=None)\n  (out_linear): Linear(in_features=64, out_features=2, bias=True)\n)","content_type":"text/plain"}}},"children":[],"key":"S5VxgCyMiH"}],"key":"JjfCaAI9HA"}],"key":"S5U7WbNm6C"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import time\nloss_train = []\nloss_val = []\nbest_loss = 1\nbest_epoch = 0\nPATH_CHECKPOINT = \"./checkpoint/best_origin_pred.pt\"\nstart_time = time.perf_counter()\n\nnb_epoch = tqdm(range(5000))\n\nfor epoch in nb_epoch:\n    loss_train.append(train(train_loader, device))\n    loss_val.append(validation(val_loader, device))\n    \n    if loss_val[-1] < best_loss:\n        best_loss = loss_val[-1]\n        best_epoch = epoch\n        torch.save(model.state_dict(), PATH_CHECKPOINT)\n    if early_stopper.early_stop(loss_val[-1]):\n        print(f\"early stopping at epoch {epoch}: train loss={loss_train[-1]}, val loss={loss_val[-1]}\")\n        break\n    nb_epoch.set_postfix_str(f\"train loss={loss_train[-1]}, val loss={loss_val[-1]}\")","visibility":"show","key":"sohE6nnTWS"},{"type":"outputs","id":"1xEXtZp8PUobYv61LzMTN","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"  5%|▊              | 256/5000 [01:27<26:54,  2.94it/s, train loss=0.021886388072744012, val loss=0.043487317327942164]"},"children":[],"key":"XBNoUGHyrA"},{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"early stopping at epoch 256: train loss=0.02277164231054485, val loss=0.04359272601349013\n"},"children":[],"key":"xLXWNT2IOe"},{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"\n"},"children":[],"key":"dhpYLwsnXb"}],"visibility":"show","key":"xIWJbAi13s"}],"visibility":"show","key":"Rgf8BLzng1"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# restore best model\n# PATH_CHECKPOINT = \"./checkpoint/best_origin_pred.pt\"\nmodel.load_state_dict(torch.load(PATH_CHECKPOINT))\nprint(f\"best loss={best_loss}, model eval loss={validation(test_dataset, device)} at epoch {best_epoch}\")","visibility":"show","key":"bRFYBdak7g"},{"type":"outputs","id":"f-mIinYiILmHuPvN_If94","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"best loss=0.04338420767869268, model eval loss=0.052245261592470345 at epoch 236\n"},"children":[],"key":"IRi9T1IdKi"}],"visibility":"show","key":"Hu6TpLPmuv"}],"visibility":"show","key":"CeYhYxDQEy"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = test_dataset[0]\nmodel = model.to('cpu')\npred = model(data.pos, data.signal, data.edge_index, data.edge_weight).detach()\npred.shape","visibility":"show","key":"o68qDuRZG6"},{"type":"outputs","id":"k0x6sUOEmfPaxup0wANo7","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":24,"metadata":{},"data":{"text/plain":{"content":"torch.Size([1, 2])","content_type":"text/plain"}}},"children":[],"key":"J7XnZgAlAV"}],"visibility":"show","key":"kPhA83iWVO"}],"visibility":"show","key":"wz5NtCgMGC"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"print(f\"target={data.y}, pred={pred}\")","key":"nvyYUkEypt"},{"type":"outputs","id":"8S1nCnU7vul1P7Ci4nCqf","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"target=tensor([[0.6667, 0.3333]]), pred=tensor([[0.6985, 0.5135]])\n"},"children":[],"key":"GJIZtexama"}],"key":"LbmryFzdPZ"}],"key":"fP102sOCf6"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Get the first 10 graphs from the dataset\nfor i in range(10):\n    data = test_dataset[i].clone()  # or normalized_dataset[i] if wrapped\n    data = data.to(device)\n\n    # Run prediction\n    with torch.no_grad():\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, batch=None)\n\n    # Denormalize\n    data.pred = normalized_dataset.denormalize(pred)  # model output\n    data.y = normalized_dataset.denormalize(data.y)  # true origin\n\n    # Optional: error vector for color\n    data.error = torch.norm(data.pred - data.y, dim=-1).unsqueeze(0)  # shape [1]\n\n    # Visualize\n    visualize_graph_torch(data, color=\"signal\", pred=True)","key":"cnXpy3hU9F"},{"type":"outputs","id":"pD_RU0OqDvZtxmfraOqqW","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"4d89a69c20de583d523d6443e6fe231e","path":"/4d89a69c20de583d523d6443e6fe231e.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"SuYkyG1KIq"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"69d8f5cd98576c70faf126dbbb21a043","path":"/69d8f5cd98576c70faf126dbbb21a043.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"E7EArAjigY"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"536535841f184b329911177b296babf1","path":"/536535841f184b329911177b296babf1.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"ZWq5D85KFo"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"f73804158fe64490a162f805e022755c","path":"/f73804158fe64490a162f805e022755c.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"CfcoK8xUXb"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"0575fe27571181e870f01d19e7e9e6c6","path":"/0575fe27571181e870f01d19e7e9e6c6.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"bM3s7sA9b3"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"b2a10090f7583999fb9058ac89246c3a","path":"/b2a10090f7583999fb9058ac89246c3a.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"p1brkX3QmG"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"161311b831b075104be1dc4a8948b86e","path":"/161311b831b075104be1dc4a8948b86e.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"xMHCwtD8AQ"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"4a01c77f46ab713720526f71f61a3ad0","path":"/4a01c77f46ab713720526f71f61a3ad0.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"fUTVomZIla"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"f9154bfac12f39a549d58a8e7a24973a","path":"/f9154bfac12f39a549d58a8e7a24973a.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"bY3nzFGo7y"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"4e713682cc6217914c7ae19096bae223","path":"/4e713682cc6217914c7ae19096bae223.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"dnjMBCka9i"}],"key":"aF6Cexgfav"}],"key":"LXCI4YQwdb"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"plt.plot(loss_train, label=\"Train\")\nplt.plot(loss_val, label = \"Validation\")\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.5))","visibility":"show","key":"raUh83SoOB"},{"type":"outputs","id":"NjHFEEMfemKxAHKclf8rW","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"c27add1cccf3335a197d396e2fe10812","path":"/c27add1cccf3335a197d396e2fe10812.png"},"text/plain":{"content":"<Figure size 640x480 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"FKLLMc3pLq"}],"visibility":"show","key":"TrtIhbF6GV"}],"visibility":"show","key":"x0RmAEQTHt"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"location error","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"WZoVEYUOXF"}],"identifier":"location-error","label":"location error","html_id":"location-error","implicit":true,"key":"eUCWLsrGxw"}],"key":"M6FoPWSt2Z"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"@torch.no_grad()\ndef evaluate(model, test_loader, normalized_dataset, device):\n    \"\"\"\n    Evaluate model on full test set and compute average error in x and y.\n\n    Args:\n        model: Trained model\n        test_loader: DataLoader for the test set\n        normalized_dataset: NormalizeTargetsWrapper instance (for denormalization)\n        device: torch.device\n\n    Returns:\n        avg_error_x, avg_error_y\n    \"\"\"\n    model.eval()\n\n    pred_all = []\n    true_all = []\n\n    for data in test_loader:\n        data = data.to(device)\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)\n\n        # Denormalize both prediction and target\n        pred_denorm = normalized_dataset.denormalize(pred)\n        true_denorm = normalized_dataset.denormalize(data.y)\n\n        pred_all.append(pred_denorm.cpu())\n        true_all.append(true_denorm.cpu())\n\n    # Stack all predictions and truths\n    pred_all = torch.cat(pred_all, dim=0)  # shape [num_graphs, 2]\n    true_all = torch.cat(true_all, dim=0)  # shape [num_graphs, 2]\n\n    # Compute absolute errors\n    abs_errors = torch.abs(pred_all - true_all)  # shape [num_graphs, 2]\n    avg_error_x = abs_errors[:, 0].mean().item()\n    avg_error_y = abs_errors[:, 1].mean().item()\n\n    print(f\"Average Error — X: {avg_error_x:.3f}, Y: {avg_error_y:.3f}\")\n    return avg_error_x, avg_error_y","key":"bRcXCldVZ8"},{"type":"outputs","id":"GwDkn9weXzJY3cPSNQW0g","children":[],"key":"cGLwYaHhaK"}],"key":"oz6frTYbn0"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"arror_x, error_y = evaluate(model, test_loader, normalized_dataset, device)","key":"dDqtMU3mYN"},{"type":"outputs","id":"ky7vpkY-5BhuJOewlIcxi","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"Average Error — X: 0.480, Y: 0.547\n"},"children":[],"key":"E4QqQ8gzVG"}],"key":"XONlpXpmhB"}],"key":"kvmRUcsaru"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":4,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Saving results","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"JYTYu19G3s"}],"identifier":"saving-results","label":"Saving results","html_id":"saving-results","implicit":true,"key":"QTAY8T2sUY"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"2 GAT layers X: 0.412, Y: 0.420","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"GI6U43opGu"}],"key":"IWS3l4lLaZ"},{"type":"paragraph","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"text","value":"1 GAT layer X: 0.382, Y: 0.374","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"MaACuJWolt"}],"key":"kWkwC7tyJa"}],"key":"R8BMFvRs7Y"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"","key":"llZCFwJpMk"},{"type":"outputs","id":"IkDuqpISdmMqo3o6p7pnn","children":[],"key":"St5Nq5ooOB"}],"key":"YtxAzdoerH"}],"key":"jLeoLs5fTK"},"references":{"cite":{"order":[],"data":{}}}}