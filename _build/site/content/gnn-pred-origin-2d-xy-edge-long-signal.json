{"version":3,"kind":"Notebook","sha256":"aae7a0ab868ea0fb45fc9e34329ed7bd78d0614798a909e3f9a7429ebe7baf50","slug":"gnn-pred-origin-2d-xy-edge-long-signal","location":"/notebooks/Loic/GNN/other versions/GNN_pred_origin_2d_xy_edge_long_signal.ipynb","dependencies":[],"frontmatter":{"title":"Training a GNN: Long signal and edges x+y dist","content_includes_title":false,"kernelspec":{"name":"conda-env-pangeo_torch-py","display_name":"Python [conda env:pangeo_torch]","language":"python"},"authors":[{"id":"Amanda M. Thomas, William Marfo, and Loïc Bachelot","name":"Amanda M. Thomas, William Marfo, and Loïc Bachelot"}],"keywords":["earthquake","catalog","ML","AI"],"numbering":{"title":{"offset":4}},"exports":[{"format":"ipynb","filename":"GNN_pred_origin_2d_xy_edge_long_signal.ipynb","url":"/GNN_pred_origin_2d_x-e2297e0a38cf9c31e048fd18fb101ee7.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Parameters of simualation:","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"MPX8YiKnDX"}],"key":"Nx0abCSlZD"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":4,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Domain size = 100*100","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"Q3jqMcRI6c"}],"key":"DYte0cO8QF"}],"key":"UwlOwT0X0l"},{"type":"listItem","spread":true,"position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"velocity = .5","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"xY3AxHG8mM"}],"key":"pNPzm6WHRZ"}],"key":"V6uHfrwFhw"},{"type":"listItem","spread":true,"position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"signal size = 200","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"WhMHHZvPI8"}],"key":"nFm5QsVDwi"}],"key":"tjqrqObjev"},{"type":"listItem","spread":true,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"number station = 50-65","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"xsZ1gJ6PqF"}],"key":"Etw5X5CNeC"}],"key":"dEOjzH9iuv"}],"key":"flzeB4IgTc"}],"key":"h6zgcfMyRp"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import pickle\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom torch_geometric.data import Data\nimport torch\nimport torch_geometric\nfrom torch_geometric.transforms import KNNGraph\nfrom torch_geometric.data import InMemoryDataset, Data\nfrom torch.nn import Linear, Parameter, LeakyReLU, Conv2d, MaxPool1d\nfrom torch_geometric.nn import GCNConv, MessagePassing, MLP, GATv2Conv, global_mean_pool, GlobalAttention\nfrom scipy.spatial import distance\nfrom torch_geometric.utils import add_self_loops, degree\nfrom tqdm import tqdm\nfrom torch import nn\n\nimport shutil\nimport os","visibility":"show","key":"UESqJEqLlA"},{"type":"outputs","id":"_e5tRwzHZ2cuDhM29AlON","children":[],"visibility":"show","key":"oXWH8KZzhd"}],"visibility":"show","key":"KmPudLqMOb"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"def visualize_graph_torch(g, color, pred=False):\n    fig, ax = plt.subplots(figsize=(6, 6))\n\n    # Plot edges\n    for edge in g.edge_index.T:\n        ax.plot(\n            [g.pos[edge[0]][0], g.pos[edge[1]][0]],\n            [g.pos[edge[0]][1], g.pos[edge[1]][1]],\n            color='blue', linewidth=1\n        )\n\n    # Plot nodes with color\n    scatter = ax.scatter(\n        x=g.pos.T[0],\n        y=g.pos.T[1],\n        alpha=1,\n        c=g[color][:, 0],\n        s=150\n    )\n\n    # Add color legend\n    legend1 = ax.legend(*scatter.legend_elements(), loc='center left', bbox_to_anchor=(1, 0.5))\n    ax.add_artist(legend1)\n\n    # Plot origin as a red cross (if present)\n    if hasattr(g, 'y') and g.y[0].numel() == 2:\n        ax.plot(g.y[0][0], g.y[0][1], 'rx', markersize=12, markeredgewidth=3, label='Origin')\n        ax.legend()\n        \n    if pred == True:\n        if hasattr(g, 'pred') and g.pred[0].numel() == 2:\n            ax.plot(g.pred[0][0], g.pred[0][1], 'bx', markersize=12, markeredgewidth=3, label='Prediction')\n            ax.legend()\n\n    plt.show()","visibility":"show","key":"retDDqP3uh"},{"type":"outputs","id":"9DGpgvbrnqXW2KdYgJyJI","children":[],"visibility":"show","key":"RxAZYGaLbn"}],"visibility":"show","key":"BUZ53B4TCf"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"def plot_signals_subplots_by_distance(data, velocity=0.5, sampling_rate=1.0, title=\"Signals by distance to origin\"):\n    \"\"\"\n    Plot each station's signal in its own subplot, ordered by distance to origin,\n    with vertical lines showing the arrival time of the sine wave.\n\n    Args:\n        data (Data): PyG Data object with:\n            - pos: [num_nodes, 2]\n            - signal: [num_nodes, SIGNAL_SIZE]\n            - y: [1, 2] or [2]\n        velocity (float): wave propagation speed (units/sec)\n        sampling_rate (float): samples per unit (Hz)\n        title (str): Figure title\n    \"\"\"\n    pos = data.pos.cpu().numpy()\n    signals = data.signal.cpu().numpy()\n    origin = data.y.squeeze().cpu().numpy()\n\n    num_nodes = pos.shape[0]\n\n    # Compute distances and arrival times\n    distances = np.array([distance.euclidean(origin, pos[i].tolist()) for i in range(num_nodes)])\n    arrival_samples = (distances / velocity * sampling_rate).astype(int)\n    sort_idx = np.argsort(distances)\n\n    # Plot\n    fig, axs = plt.subplots(num_nodes, 1, figsize=(10, 2 * num_nodes), sharex=True)\n\n    for i, idx in enumerate(sort_idx):\n        ax = axs[i]\n        signal = signals[idx]\n\n        ax.plot(np.arange(len(signal)), signal, color='black', linewidth=1)\n        ax.axvline(arrival_samples[idx], color='red', linestyle='--', linewidth=1, label='arrival')\n        ax.set_ylabel(f\"{distances[idx]:.2f}\", rotation=0, labelpad=25)\n        ax.grid(True, linestyle='--', alpha=0.3)\n\n    axs[-1].set_xlabel(\"Time (samples)\")\n    fig.suptitle(title, fontsize=14)\n    plt.tight_layout(rect=[0, 0, 1, 0.98])\n    plt.show()","key":"clqFn8K0nw"},{"type":"outputs","id":"mLXov-F2fdK9A85rrNkvK","children":[],"key":"u3QYcak6ge"}],"key":"O1Ux685WGN"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"SIGNAL_SIZE = 200\nNB_GRAPHS = 1000\nDOMAIN_SIZE = 100","visibility":"show","key":"UU3PRBdUB1"},{"type":"outputs","id":"E813CidXOahcnYsTZnZTe","children":[],"visibility":"show","key":"cv7NtyxDS8"}],"visibility":"show","key":"HYgVsukVec"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"def add_edge_weight(g):\n    edge_weight = []\n    for edge in g.edge_index.T:\n        dx = g.pos[edge[1]][0] - g.pos[edge[0]][0]\n        dy = g.pos[edge[1]][1] - g.pos[edge[0]][1]\n        edge_weight.append([dx, dy])\n    g.edge_weight = torch.tensor(edge_weight, dtype=torch.float)\n    return g","visibility":"show","key":"kwDZSV1An1"},{"type":"outputs","id":"FHPHOgcLvEcpaGfgnxtbj","children":[],"visibility":"show","key":"XVMS1cb402"}],"visibility":"show","key":"aJvFVWnrtq"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class SinOriginDataset_v3(InMemoryDataset):\n    \"\"\"\n    Synthetic dataset for GNN training. Each graph has:\n    - Random 2D node positions.\n    - Node features as sine signals based on distance to a hidden origin.\n    - A target: the origin used to generate signals (same for all nodes in a graph).\n    \"\"\"\n\n    def __init__(self, root, transform=None, pre_transform=None, nb_graph=10):\n        self.nb_graph = nb_graph\n        super(SinOriginDataset_v3, self).__init__(root, transform, pre_transform)\n        self.data, self.slices = torch.load(self.processed_paths[0], weights_only=False)\n\n    @property\n    def raw_file_names(self):\n        return 0  # No raw files needed\n\n    @property\n    def processed_file_names(self):\n        return 'data.pt'\n\n    def process(self):\n        data_list = []\n        # Configurable parameters\n        frequency = 1.0         # Hz\n        velocity = 0.5          # units/sec\n        sampling_rate = 1.0     # samples/unit\n        noise_std = 0.1         # noise standard deviation\n        base_sine_wave = np.sin(np.arange(SIGNAL_SIZE))\n        for _ in range(self.nb_graph):\n            # Random number of nodes between 5 and 15\n            nb_nodes = np.random.randint(50, 65)\n\n            # Random 2D positions for nodes\n            pos = torch.tensor(np.random.uniform(0, DOMAIN_SIZE, size=(nb_nodes, 2)), dtype=torch.float)\n\n            # Select a random origin point (the target)\n            origin = np.random.randint(0, DOMAIN_SIZE, size=2)\n            origin_tensor = torch.tensor(origin, dtype=torch.float)\n\n            # Generate delayed sine signals\n            signal_list = []\n\n            for i in range(nb_nodes):\n                dist = distance.euclidean(origin, pos[i].tolist())\n                delay = dist / velocity\n                delay_samples = int(delay * sampling_rate)\n\n                # Base waveform\n                waveform = np.random.normal(0, noise_std, size=SIGNAL_SIZE)\n\n                if delay_samples < SIGNAL_SIZE:\n                    insert_length = SIGNAL_SIZE - delay_samples\n                    waveform[delay_samples:] += base_sine_wave[:insert_length]\n\n                signal_list.append(waveform)\n\n            # Convert signal list to tensor\n            signal = torch.tensor(np.array(signal_list), dtype=torch.float32).reshape(nb_nodes, SIGNAL_SIZE)\n\n            # Construct PyG Data object\n            g = Data(pos=pos, signal=signal, y=origin_tensor.unsqueeze(0))  # y shape (1, 2)\n\n            data_list.append(g)\n\n        # Optional transformations\n        if self.pre_transform is not None:\n            data_list = [self.pre_transform(data) for data in data_list]\n            data_list = [add_edge_weight(data) for data in data_list]\n\n        # Save processed data\n        data, slices = self.collate(data_list)\n        torch.save((data, slices), self.processed_paths[0])","visibility":"show","key":"D8i6zSdaur"},{"type":"outputs","id":"WFOmH5-raReuFkR9G0-AQ","children":[],"visibility":"show","key":"Ai9tY962k2"}],"visibility":"show","key":"bupVrMuxNZ"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# delete old dataset\nshutil.rmtree('./sin_train_v3/processed')  # remove all processed files\n\nraw_dataset = SinOriginDataset_v3(root=\"./sin_train_v3\", pre_transform=KNNGraph(k=5, loop=False, force_undirected=True), \n                       nb_graph=NB_GRAPHS)\nraw_dataset","visibility":"show","key":"pUNttHLIuU"},{"type":"outputs","id":"fV2qMKWTxLn034ycX89pW","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"Processing...\nDone!\n"},"children":[],"key":"NLKKsXohIH"},{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":7,"metadata":{},"data":{"text/plain":{"content":"SinOriginDataset_v3(1000)","content_type":"text/plain"}}},"children":[],"key":"A2LCzQw5FK"}],"visibility":"show","key":"ARBpsDANDV"}],"visibility":"show","key":"SxzbHCIh91"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = raw_dataset[0]\ndata","visibility":"show","key":"vjKZ6h9tff"},{"type":"outputs","id":"eBBgkkkTee8HrV0WFX2nJ","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":8,"metadata":{},"data":{"text/plain":{"content":"Data(y=[1, 2], pos=[50, 2], signal=[50, 200], edge_index=[2, 302], edge_weight=[302, 2])","content_type":"text/plain"}}},"children":[],"key":"mEWYxPWg2h"}],"visibility":"show","key":"UhPRgRtKKZ"}],"visibility":"show","key":"s1ZGUIKDTd"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"visualize_graph_torch(data, color='signal')","visibility":"show","key":"gyKDMQ8EA1"},{"type":"outputs","id":"njlYxbc2Njd079OwGfLQa","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"81a41aadb29975cf5112cbef194aca95","path":"/81a41aadb29975cf5112cbef194aca95.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"XbZ5pWr8aZ"}],"visibility":"show","key":"e7bxmp9Ygg"}],"visibility":"show","key":"TTXDw7RsM6"},{"type":"block","kind":"notebook-code","data":{"scrolled":true},"children":[{"type":"code","lang":"python","executable":true,"value":"plot_signals_subplots_by_distance(data)","key":"GHD5MYIf46"},{"type":"outputs","id":"PQpNmO3o0RTiywLt2X6K2","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"8ebf2b3b58db3ef780133dca95cfe03e","path":"/8ebf2b3b58db3ef780133dca95cfe03e.png"},"text/plain":{"content":"<Figure size 1000x10000 with 50 Axes>","content_type":"text/plain"}}},"children":[],"key":"XgsGKEjnDt"}],"key":"XyftTJYXyB"}],"key":"nIe1Z2vJIv"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Preprocessing","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"hOZ5GioRS7"}],"identifier":"preprocessing","label":"Preprocessing","html_id":"preprocessing","implicit":true,"key":"P9EtcUkm7k"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Normalization of output step, input is already -1 to 1","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"y5ErIEJ3hK"}],"key":"LsGt8STOKL"}],"key":"NHDZxLm9TG"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"class NormalizeTargetsWrapper(torch.utils.data.Dataset):\n    \"\"\"\n    Wraps a PyG dataset to normalize `y` from [min_val, max_val] → [-1, 1].\n    \"\"\"\n    def __init__(self, dataset, min_val, max_val):\n        self.dataset = dataset\n        self.min_val = min_val\n        self.max_val = max_val\n\n    def __len__(self):\n        return len(self.dataset)\n\n    def __getitem__(self, idx):\n        data = self.dataset[idx].clone()\n        # scale from [min, max] to [-1, 1]\n        data.y = 2 * (data.y - self.min_val) / (self.max_val - self.min_val) - 1\n        return data\n\n    def denormalize(self, norm_y):\n        # scale back from [-1, 1] to [min, max]\n        return 0.5 * (norm_y + 1) * (self.max_val - self.min_val) + self.min_val","key":"Fwdad1Iufx"},{"type":"outputs","id":"U0loMYV-juLIA380Q6u8W","children":[],"key":"kL3RyimI3q"}],"key":"WWekZQEaPt"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"normalized_dataset = NormalizeTargetsWrapper(raw_dataset, min_val=0, max_val=DOMAIN_SIZE)","key":"MfjThLYF9B"},{"type":"outputs","id":"LeDOeQq-Omc_pFIMF8cBW","children":[],"key":"CSkzdDrSiK"}],"key":"lVWbc0ghwm"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Build the GNN","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"hvYafN3nRG"}],"identifier":"build-the-gnn","label":"Build the GNN","html_id":"build-the-gnn","implicit":true,"key":"ZuS16tv8Kl"}],"key":"WZ1cXro7zG"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class MLPNet(torch.nn.Module):\n    \"\"\"\n    GNN model with MLP → 2x GATv2Conv → MLP for graph-level origin prediction.\n\n    Args:\n        channels_x (int): Positional input features per node.\n        channels_y (int): Signal features per node.\n        hidden_channels (int): Hidden dimension.\n        dropout (float): Dropout probability.\n        self_loops (bool): Whether to add self-loops to GATv2Conv.\n\n    Output:\n        Tensor of shape (batch_size, 2), normalized origin coordinates (in [-1, 1]).\n    \"\"\"\n    def __init__(self, channels_x, channels_y, hidden_channels=128, dropout=0.3, self_loops=True):\n        super(MLPNet, self).__init__()\n        torch.manual_seed(1234)\n\n        self.mlp_in = MLP([channels_x + channels_y, 64, hidden_channels])\n\n        self.conv1 = GATv2Conv(\n            in_channels=hidden_channels,\n            out_channels=hidden_channels,\n            heads=2,\n            edge_dim=2,\n            add_self_loops=self_loops,\n            concat=True\n        )\n\n        self.conv2 = GATv2Conv(\n            in_channels=hidden_channels * 2,  # output of conv1 with 2 heads\n            out_channels=hidden_channels,\n            heads=2,\n            edge_dim=2,\n            add_self_loops=self_loops,\n            concat=True\n        )\n\n        self.mlp_out = MLP([hidden_channels * 2, 64], act=nn.LeakyReLU(), dropout=dropout)\n        self.att_pool = GlobalAttention(\n            gate_nn=torch.nn.Sequential(\n                nn.Linear(64, 32),\n                nn.ReLU(),\n                nn.Linear(32, 1)\n            )\n        )\n\n        self.out_linear = Linear(64, 2)\n        \n    def forward(self, pos, signal, edge_index, edge_weight, batch=None):\n        x = torch.cat([pos, signal], dim=-1)\n        x = self.mlp_in(x)\n        x = self.conv1(x, edge_index, edge_weight)\n        x = self.conv2(x, edge_index, edge_weight)\n        x = self.mlp_out(x)\n\n        if batch is None:\n            batch = torch.zeros(x.size(0), dtype=torch.long, device=x.device)\n\n        graph_repr = self.att_pool(x, batch)\n        return self.out_linear(graph_repr).tanh()","visibility":"show","key":"HLGHqbPA0T"},{"type":"outputs","id":"8cFfUe9_nI08KcBeRotYP","children":[],"visibility":"show","key":"m05pL1jmh3"}],"visibility":"show","key":"JGuojQEymu"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"training","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"n6T2r7SUB8"}],"identifier":"training","label":"training","html_id":"training","implicit":true,"key":"FJumz7ZHKw"}],"key":"oNWirlzLEj"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"from torch_geometric.loader import DataLoader\nfrom sklearn.model_selection import train_test_split\n\ntrain_dataset, val_dataset = train_test_split(normalized_dataset, train_size=0.8, random_state=42)\nval_dataset, test_dataset = train_test_split(val_dataset, train_size=0.8, random_state=42)\n\ntrain_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)\nval_loader = DataLoader(val_dataset, batch_size=64, shuffle=False)\ntest_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)\n\n\nprint(f\"nb graph train ds= {len(train_dataset)}, nb graph val ds= {len(val_dataset)}, nb graph test ds= {len(test_dataset)}\")","visibility":"show","key":"xaSesVv1p5"},{"type":"outputs","id":"4ie2k1y0ipGBY7mu73ZkA","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"nb graph train ds= 800, nb graph val ds= 160, nb graph test ds= 40\n"},"children":[],"key":"wF7bu6d6ai"}],"visibility":"show","key":"UeeGUPOjOc"}],"visibility":"show","key":"JQYxIclw09"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = train_dataset[0]\ndata","visibility":"show","key":"yp9eW8CiGm"},{"type":"outputs","id":"mENyOH2ukAzvFP037F4Ua","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":22,"metadata":{},"data":{"text/plain":{"content":"Data(y=[1, 2], pos=[57, 2], signal=[57, 200], edge_index=[2, 348], edge_weight=[348, 2])","content_type":"text/plain"}}},"children":[],"key":"nElmHPeshn"}],"visibility":"show","key":"qGtSu3y5Tu"}],"visibility":"show","key":"tBGa8QJP2n"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"for batch in train_loader:\n    print(batch.y.shape)  # Should be [batch_size, 2]\n    break","key":"K3yPJrSdYQ"},{"type":"outputs","id":"lSScHYz1f20a74yZtvl2D","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"torch.Size([64, 2])\n"},"children":[],"key":"kVhZZNDbUN"}],"key":"A0Sd9UZYEF"}],"key":"tPpC972fT4"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class EarlyStopper:\n    \"\"\"\n    A class for early stopping the training process when the validation loss stops improving.\n    \"\"\"\n    def __init__(self, patience=1, min_delta=0):\n        self.patience = patience\n        self.min_delta = min_delta\n        self.counter = 0\n        self.min_validation_loss = np.inf\n\n    def early_stop(self, validation_loss):\n        if validation_loss < self.min_validation_loss:\n            self.min_validation_loss = validation_loss\n            self.counter = 0\n        elif validation_loss > (self.min_validation_loss + self.min_delta):\n            self.counter += 1\n            if self.counter >= self.patience:\n                return True\n        return False\n\n\ndef train(dataloader, device):\n    model.train()\n    mean_loss = 0\n    for data in dataloader:\n        data = data.to(device)\n        optimizer.zero_grad()\n\n        # Forward pass\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)  # → shape [num_graphs, 2]\n\n        # Check shape of target\n        assert data.y.shape == pred.shape, f\"Expected y shape {pred.shape}, got {data.y.shape}\"\n\n        loss = criterion(pred, data.y)\n        loss.backward()\n        optimizer.step()\n        mean_loss += loss.item()\n    return mean_loss / len(dataloader)\n\n\n@torch.no_grad()\ndef validation(dataloader, device):\n    model.eval()\n    total_loss = 0\n    for data in dataloader:\n        data = data.to(device)\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)\n        loss = criterion(pred, data.y)\n        total_loss += loss.item()\n    return total_loss / len(dataloader)","visibility":"show","key":"u1VGuT60op"},{"type":"outputs","id":"F8AKCe_29oKn5nMqSVfth","children":[],"visibility":"show","key":"Rmu5XOiJl2"}],"visibility":"show","key":"KJe3SK2Di7"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":4,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"set training parameters","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"vZx6xm475F"}],"identifier":"set-training-parameters","label":"set training parameters","html_id":"set-training-parameters","implicit":true,"key":"UlEr5yeb8T"}],"key":"hdQzotoMhu"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n\nmodel = MLPNet(data.pos.shape[1], data.signal.shape[1], hidden_channels=128)\n\ncriterion = torch.nn.MSELoss()  # Define loss criterion.\noptimizer = torch.optim.Adam(model.parameters(), lr=0.0001)  # Define optimizer.\nearly_stopper = EarlyStopper(patience=20, min_delta=0.0)\nprint(device)","visibility":"show","key":"bfMVgHB4ho"},{"type":"outputs","id":"cfQsTlt1Fo25I7p4Jq0Dz","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"cpu\n"},"children":[],"key":"vsKmhGu0nP"},{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"C:\\Users\\loicb\\miniconda3\\envs\\pangeo_torch\\Lib\\site-packages\\torch_geometric\\deprecation.py:26: UserWarning: 'nn.glob.GlobalAttention' is deprecated, use 'nn.aggr.AttentionalAggregation' instead\n  warnings.warn(out)\n"},"children":[],"key":"rxaz0k7R4q"}],"visibility":"show","key":"MErZrzIUQU"}],"visibility":"show","key":"rnwCRGgMwp"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"model","key":"nr0qckMDO8"},{"type":"outputs","id":"rq2jxeVUsh8EWjQqw8Ehz","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":26,"metadata":{},"data":{"text/plain":{"content":"MLPNet(\n  (mlp_in): MLP(202, 64, 128)\n  (conv1): GATv2Conv(128, 128, heads=2)\n  (conv2): GATv2Conv(256, 128, heads=2)\n  (mlp_out): MLP(256, 64)\n  (att_pool): GlobalAttention(gate_nn=Sequential(\n    (0): Linear(in_features=64, out_features=32, bias=True)\n    (1): ReLU()\n    (2): Linear(in_features=32, out_features=1, bias=True)\n  ), nn=None)\n  (out_linear): Linear(in_features=64, out_features=2, bias=True)\n)","content_type":"text/plain"}}},"children":[],"key":"iaLWDu0OU7"}],"key":"oZbpPtNgPx"}],"key":"Xq3ZnhBUEd"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import time\nloss_train = []\nloss_val = []\nbest_loss = 1\nbest_epoch = 0\nPATH_CHECKPOINT = \"./checkpoint/best_origin_pred.pt\"\nstart_time = time.perf_counter()\n\nnb_epoch = tqdm(range(5000))\n\nfor epoch in nb_epoch:\n    loss_train.append(train(train_loader, device))\n    loss_val.append(validation(val_loader, device))\n    \n    if loss_val[-1] < best_loss:\n        best_loss = loss_val[-1]\n        best_epoch = epoch\n        torch.save(model.state_dict(), PATH_CHECKPOINT)\n    if early_stopper.early_stop(loss_val[-1]):\n        print(f\"early stopping at epoch {epoch}: train loss={loss_train[-1]}, val loss={loss_val[-1]}\")\n        break\n    nb_epoch.set_postfix_str(f\"train loss={loss_train[-1]}, val loss={loss_val[-1]}\")","visibility":"show","key":"aNTjVU3VCy"},{"type":"outputs","id":"an7zYafKBz6ym1rE3ryVn","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"  5%|▋            | 270/5000 [25:15<7:22:34,  5.61s/it, train loss=0.0034616878793503228, val loss=0.00776027903581659]"},"children":[],"key":"HeJYOjkfJP"},{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"early stopping at epoch 270: train loss=0.0034106654974703607, val loss=0.007571736816316843\n"},"children":[],"key":"k04Ev6Uqhk"},{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"\n"},"children":[],"key":"Ev1MuSrf5e"}],"visibility":"show","key":"Q9zRrBAJH9"}],"visibility":"show","key":"O3jlIL2Nm3"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# restore best model\n# PATH_CHECKPOINT = \"./checkpoint/best_origin_pred.pt\"\nmodel.load_state_dict(torch.load(PATH_CHECKPOINT))\nprint(f\"best loss={best_loss}, model eval loss={validation(test_dataset, device)} at epoch {best_epoch}\")","visibility":"show","key":"wiGTHygCJ2"},{"type":"outputs","id":"2akxZyhesu6ngXrxj2lS6","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"best loss=0.007528563495725393, model eval loss=0.008281604402145603 at epoch 250\n"},"children":[],"key":"s8Xyqz8E6m"}],"visibility":"show","key":"qgaRXxSP1Z"}],"visibility":"show","key":"oXmvkfeiaL"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = test_dataset[0]\nmodel = model.to('cpu')\npred = model(data.pos, data.signal, data.edge_index, data.edge_weight).detach()\npred.shape","visibility":"show","key":"ht4ShGjhGN"},{"type":"outputs","id":"lCkETemXYTqVC1v2Er6Ag","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":29,"metadata":{},"data":{"text/plain":{"content":"torch.Size([1, 2])","content_type":"text/plain"}}},"children":[],"key":"DR9KebLsAq"}],"visibility":"show","key":"xV04mEf1E4"}],"visibility":"show","key":"dp9dyn5tDI"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"print(f\"target={data.y}, pred={pred}\")","key":"ZbtAGt6jWz"},{"type":"outputs","id":"G0ywlCTxbLVJdAIPLsB1G","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"target=tensor([[-0.1600, -0.1200]]), pred=tensor([[-0.2695, -0.0867]])\n"},"children":[],"key":"FmJbBtvTGc"}],"key":"ZdjOz06Kxq"}],"key":"sFtA0TLKJh"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Get the first 10 graphs from the dataset\nfor i in range(10):\n    data = test_dataset[i].clone()  # or normalized_dataset[i] if wrapped\n    data = data.to(device)\n\n    # Run prediction\n    with torch.no_grad():\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, batch=None)\n\n    # Denormalize\n    data.pred = normalized_dataset.denormalize(pred)  # model output\n    data.y = normalized_dataset.denormalize(data.y)  # true origin\n\n    # Optional: error vector for color\n    data.error = torch.norm(data.pred - data.y, dim=-1).unsqueeze(0)  # shape [1]\n\n    # Visualize\n    visualize_graph_torch(data, color=\"signal\", pred=True)","key":"mBErPt11O1"},{"type":"outputs","id":"QiGgXIcXI4hHY0c98rS-O","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"03f5e19549f4f9c2a223e0c9961f1eef","path":"/03f5e19549f4f9c2a223e0c9961f1eef.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"oxTLknx8sx"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"0c7105cbf8266ecb4a7adb05d80434d8","path":"/0c7105cbf8266ecb4a7adb05d80434d8.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"oHhLC2Z4dF"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"6ed97d1d53cb714150d0214ff5b1b3bf","path":"/6ed97d1d53cb714150d0214ff5b1b3bf.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"V6fzcSRLoA"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"f20ccc65abd63801942d1a6a087d0992","path":"/f20ccc65abd63801942d1a6a087d0992.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"rbbuwTuB9Q"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"d76a72195399799c13cccbfb1aeaa078","path":"/d76a72195399799c13cccbfb1aeaa078.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"uqhNxqSych"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"3f7bcbc68416cbbf495eb1a36955c68d","path":"/3f7bcbc68416cbbf495eb1a36955c68d.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"eV8uZALSVy"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"283bc6c7985c0c5586dcbe0bec85758c","path":"/283bc6c7985c0c5586dcbe0bec85758c.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"IGY0mZJNqy"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"29de0140a7031a5bd56a9b78911087f9","path":"/29de0140a7031a5bd56a9b78911087f9.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"QIdyg1UvkU"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"5098a3eb11a9d3ca29753459575cef8e","path":"/5098a3eb11a9d3ca29753459575cef8e.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"aqy6lZejr0"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"a04e4bead3a42b5c612a1c6fbe498397","path":"/a04e4bead3a42b5c612a1c6fbe498397.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"ctTipyMTvj"}],"key":"oupq10Pal4"}],"key":"I5VySgKXNh"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"plt.plot(loss_train, label=\"Train\")\nplt.plot(loss_val, label = \"Validation\")\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.5))","visibility":"show","key":"Sgi3jv0gXQ"},{"type":"outputs","id":"hyNLls-Py3nZyLpmZ7V1I","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"4ea8293f3c77cf673f0ce15b5a607685","path":"/4ea8293f3c77cf673f0ce15b5a607685.png"},"text/plain":{"content":"<Figure size 640x480 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"ktuYdM4Nlh"}],"visibility":"show","key":"z7k2bEq9uF"}],"visibility":"show","key":"EVuOgmbi2K"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"location error","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"fIpW4yBVor"}],"identifier":"location-error","label":"location error","html_id":"location-error","implicit":true,"key":"Ac5H71W2Qy"}],"key":"HRYWBoCSxI"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"@torch.no_grad()\ndef evaluate(model, test_loader, normalized_dataset, device):\n    \"\"\"\n    Evaluate model on full test set and compute average error in x and y.\n\n    Args:\n        model: Trained model\n        test_loader: DataLoader for the test set\n        normalized_dataset: NormalizeTargetsWrapper instance (for denormalization)\n        device: torch.device\n\n    Returns:\n        avg_error_x, avg_error_y\n    \"\"\"\n    model.eval()\n\n    pred_all = []\n    true_all = []\n\n    for data in test_loader:\n        data = data.to(device)\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)\n\n        # Denormalize both prediction and target\n        pred_denorm = normalized_dataset.denormalize(pred)\n        true_denorm = normalized_dataset.denormalize(data.y)\n\n        pred_all.append(pred_denorm.cpu())\n        true_all.append(true_denorm.cpu())\n\n    # Stack all predictions and truths\n    pred_all = torch.cat(pred_all, dim=0)  # shape [num_graphs, 2]\n    true_all = torch.cat(true_all, dim=0)  # shape [num_graphs, 2]\n\n    # Compute absolute errors\n    abs_errors = torch.abs(pred_all - true_all)  # shape [num_graphs, 2]\n    avg_error_x = abs_errors[:, 0].mean().item()\n    avg_error_y = abs_errors[:, 1].mean().item()\n\n    print(f\"Average Error — X: {avg_error_x:.3f}, Y: {avg_error_y:.3f}\")\n    return avg_error_x, avg_error_y","key":"tJm4MfoV98"},{"type":"outputs","id":"jxbQ38cqGXzP0GTX2TlA8","children":[],"key":"ZOVT0WqjDn"}],"key":"MnQdhUJdgs"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"arror_x, error_y = evaluate(model, test_loader, normalized_dataset, device)","key":"A33borDwnU"},{"type":"outputs","id":"CBq0hGkuTperw0VUmoivA","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"Average Error — X: 3.776, Y: 3.533\n"},"children":[],"key":"fAIhw5rg6f"}],"key":"JuBkuxtwgU"}],"key":"A8DLgThzdw"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":4,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Saving results","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"Zj4DIraap3"}],"identifier":"saving-results","label":"Saving results","html_id":"saving-results","implicit":true,"key":"wJMTM0wPdm"},{"type":"heading","depth":5,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"one dist","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"fXfUsop67a"}],"identifier":"one-dist","label":"one dist","html_id":"one-dist","implicit":true,"key":"iqAqFcrbUd"},{"type":"paragraph","position":{"start":{"line":4,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"2 GAT layers X: 0.412, Y: 0.420\n1 GAT layer X: 0.382, Y: 0.374","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"mdp7quek1p"}],"key":"Vp1YpyAcAQ"},{"type":"heading","depth":5,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"dist x and y","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"mqz0mLTP7U"}],"identifier":"dist-x-and-y","label":"dist x and y","html_id":"dist-x-and-y","implicit":true,"key":"exPDhcvJFg"},{"type":"paragraph","position":{"start":{"line":8,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"1 GAT layer X: 0.367, Y: 0.446\n2 GAT layer X: 0.412, Y: 0.343\n2 GAT layer + self-loop","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"HIhiV2GjV4"}],"key":"ZYjtK6wslu"}],"key":"dg421u86Ya"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"","key":"TTtrNegweC"},{"type":"outputs","id":"VWlv3hJRB9FgolipoMBme","children":[],"key":"nX3fumtRpp"}],"key":"laxn9BDlcR"}],"key":"NBqSoylTcr"},"references":{"cite":{"order":[],"data":{}}}}