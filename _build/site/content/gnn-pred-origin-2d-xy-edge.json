{"version":3,"kind":"Notebook","sha256":"40e0cd03f17f55c16448b5dbaedfe1ccdcda3bea4b8cd078e9509e1788707ebf","slug":"gnn-pred-origin-2d-xy-edge","location":"/notebooks/Loic/GNN/other versions/GNN_pred_origin_2d_xy_edge.ipynb","dependencies":[],"frontmatter":{"title":"Training a GNN: short signal and edges x+y dist","content_includes_title":false,"kernelspec":{"name":"conda-env-pangeo_torch-py","display_name":"Python [conda env:pangeo_torch]","language":"python"},"authors":[{"id":"Amanda M. Thomas, William Marfo, and Loïc Bachelot","name":"Amanda M. Thomas, William Marfo, and Loïc Bachelot"}],"keywords":["earthquake","catalog","ML","AI"],"numbering":{"title":{"offset":4}},"exports":[{"format":"ipynb","filename":"GNN_pred_origin_2d_xy_edge.ipynb","url":"/GNN_pred_origin_2d_x-509338345b73640cdad4fb3e9617fcb7.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Parameters of simulation:","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"viROccut7N"}],"key":"SojuSxFvvv"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":4,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Domain size = 6*6","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"Zh0cq2iRg9"}],"key":"bEICInh1F3"}],"key":"faULp7Uc7M"},{"type":"listItem","spread":true,"position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"velocity = .5","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"WEldesDhJY"}],"key":"uq1Z82pjNC"}],"key":"C21vWQSexF"},{"type":"listItem","spread":true,"position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"signal size = 20","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"iOTRbg0ELJ"}],"key":"M0JPJfj3f8"}],"key":"pLz9IwuTTi"},{"type":"listItem","spread":true,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"number station = 20-25","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"y2Dy9SkkYK"}],"key":"aLkGfmIcRa"}],"key":"SihEdGoMhC"}],"key":"yT1Wq8nEvo"}],"key":"U54Gg24djf"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import pickle\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom torch_geometric.data import Data\nimport torch\nimport torch_geometric\nfrom torch_geometric.transforms import KNNGraph\nfrom torch_geometric.data import InMemoryDataset, Data\nfrom torch.nn import Linear, Parameter, LeakyReLU, Conv2d, MaxPool1d\nfrom torch_geometric.nn import GCNConv, MessagePassing, MLP, GATv2Conv, global_mean_pool\nfrom scipy.spatial import distance\nfrom torch_geometric.utils import add_self_loops, degree\nfrom tqdm import tqdm\nfrom torch import nn","visibility":"show","key":"CPmUyIkmok"},{"type":"outputs","id":"FKRVY2fCX5ts7N3anqROg","children":[],"visibility":"show","key":"CqpZA0DYaL"}],"visibility":"show","key":"IGGCIitQhH"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"def visualize_graph_torch(g, color, pred=False):\n    fig, ax = plt.subplots(figsize=(6, 6))\n\n    # Plot edges\n    for edge in g.edge_index.T:\n        ax.plot(\n            [g.pos[edge[0]][0], g.pos[edge[1]][0]],\n            [g.pos[edge[0]][1], g.pos[edge[1]][1]],\n            color='blue', linewidth=1\n        )\n\n    # Plot nodes with color\n    scatter = ax.scatter(\n        x=g.pos.T[0],\n        y=g.pos.T[1],\n        alpha=1,\n        c=g[color][:, 0],\n        s=150\n    )\n\n    # Add color legend\n    legend1 = ax.legend(*scatter.legend_elements(), loc='center left', bbox_to_anchor=(1, 0.5))\n    ax.add_artist(legend1)\n\n    # Plot origin as a red cross (if present)\n    if hasattr(g, 'y') and g.y[0].numel() == 2:\n        ax.plot(g.y[0][0], g.y[0][1], 'rx', markersize=12, markeredgewidth=3, label='Origin')\n        ax.legend()\n        \n    if pred == True:\n        if hasattr(g, 'pred') and g.pred[0].numel() == 2:\n            ax.plot(g.pred[0][0], g.pred[0][1], 'bx', markersize=12, markeredgewidth=3, label='Prediction')\n            ax.legend()\n\n    plt.show()","visibility":"show","key":"M7JbvAjins"},{"type":"outputs","id":"UJXmPWmzMXS-KxdplDpP6","children":[],"visibility":"show","key":"T9NHdFjE1V"}],"visibility":"show","key":"uyPi6ryR3I"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"def plot_signals_subplots_by_distance(data, velocity=0.5, sampling_rate=1.0, title=\"Signals by distance to origin\"):\n    \"\"\"\n    Plot each station's signal in its own subplot, ordered by distance to origin,\n    with vertical lines showing the arrival time of the sine wave.\n\n    Args:\n        data (Data): PyG Data object with:\n            - pos: [num_nodes, 2]\n            - signal: [num_nodes, SIGNAL_SIZE]\n            - y: [1, 2] or [2]\n        velocity (float): wave propagation speed (units/sec)\n        sampling_rate (float): samples per unit (Hz)\n        title (str): Figure title\n    \"\"\"\n    pos = data.pos.cpu().numpy()\n    signals = data.signal.cpu().numpy()\n    origin = data.y.squeeze().cpu().numpy()\n\n    num_nodes = pos.shape[0]\n\n    # Compute distances and arrival times\n    distances = np.array([distance.euclidean(origin, pos[i].tolist()) for i in range(num_nodes)])\n    arrival_samples = (distances / velocity * sampling_rate).astype(int)\n    sort_idx = np.argsort(distances)\n\n    # Plot\n    fig, axs = plt.subplots(num_nodes, 1, figsize=(10, 2 * num_nodes), sharex=True)\n\n    for i, idx in enumerate(sort_idx):\n        ax = axs[i]\n        signal = signals[idx]\n\n        ax.plot(np.arange(len(signal)), signal, color='black', linewidth=1)\n        ax.axvline(arrival_samples[idx], color='red', linestyle='--', linewidth=1, label='arrival')\n        ax.set_ylabel(f\"{distances[idx]:.2f}\", rotation=0, labelpad=25)\n        ax.grid(True, linestyle='--', alpha=0.3)\n\n    axs[-1].set_xlabel(\"Time (samples)\")\n    fig.suptitle(title, fontsize=14)\n    plt.tight_layout(rect=[0, 0, 1, 0.98])\n    plt.show()","key":"KUvktHYFGJ"},{"type":"outputs","id":"-pIXP_GRbnVMFNrlnewXV","children":[],"key":"kfngyXNszs"}],"key":"Hna6YG7ReM"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"SIGNAL_SIZE = 20\nNB_GRAPHS = 1000","visibility":"show","key":"o7ziSEhsa5"},{"type":"outputs","id":"UMn8CDL9Z8Y-HtNc7TKsr","children":[],"visibility":"show","key":"WArynyYjHL"}],"visibility":"show","key":"POiCT6Sexj"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"def add_edge_weight(g):\n    edge_weight = []\n    for edge in g.edge_index.T:\n        dx = g.pos[edge[1]][0] - g.pos[edge[0]][0]\n        dy = g.pos[edge[1]][1] - g.pos[edge[0]][1]\n        edge_weight.append([dx, dy])\n    g.edge_weight = torch.tensor(edge_weight, dtype=torch.float)\n    return g","visibility":"show","key":"fcdUo0yrQq"},{"type":"outputs","id":"jHW7QxTcehk-1gtuvnfeh","children":[],"visibility":"show","key":"kXqg5xqof9"}],"visibility":"show","key":"A3zGeWfSPH"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class SinOriginDataset_v2(InMemoryDataset):\n    \"\"\"\n    Synthetic dataset for GNN training. Each graph has:\n    - Random 2D node positions.\n    - Node features as sine signals based on distance to a hidden origin.\n    - A target: the origin used to generate signals (same for all nodes in a graph).\n    \"\"\"\n\n    def __init__(self, root, transform=None, pre_transform=None, nb_graph=10):\n        self.nb_graph = nb_graph\n        super(SinOriginDataset_v2, self).__init__(root, transform, pre_transform)\n        self.data, self.slices = torch.load(self.processed_paths[0], weights_only=False)\n\n    @property\n    def raw_file_names(self):\n        return 0  # No raw files needed\n\n    @property\n    def processed_file_names(self):\n        return 'data.pt'\n\n    def process(self):\n        data_list = []\n        # Configurable parameters\n        frequency = 1.0         # Hz\n        velocity = 0.5          # units/sec\n        sampling_rate = 1.0     # samples/unit\n        noise_std = 0.1         # noise standard deviation\n        base_sine_wave = np.sin(np.arange(SIGNAL_SIZE))\n        for _ in range(self.nb_graph):\n            # Random number of nodes between 5 and 15\n            nb_nodes = np.random.randint(20, 25)\n\n            # Random 2D positions for nodes\n            pos = torch.tensor(np.random.uniform(0, 6, size=(nb_nodes, 2)), dtype=torch.float)\n\n            # Select a random origin point (the target)\n            origin = np.random.randint(0, 6, size=2)\n            origin_tensor = torch.tensor(origin, dtype=torch.float)\n\n            # Generate delayed sine signals\n            signal_list = []\n\n            for i in range(nb_nodes):\n                dist = distance.euclidean(origin, pos[i].tolist())\n                delay = dist / velocity\n                delay_samples = int(delay * sampling_rate)\n\n                # Base waveform\n                waveform = np.random.normal(0, noise_std, size=SIGNAL_SIZE)\n\n                if delay_samples < SIGNAL_SIZE:\n                    insert_length = SIGNAL_SIZE - delay_samples\n                    waveform[delay_samples:] += base_sine_wave[:insert_length]\n\n                signal_list.append(waveform)\n\n            # Convert signal list to tensor\n            signal = torch.tensor(np.array(signal_list), dtype=torch.float32).reshape(nb_nodes, SIGNAL_SIZE)\n\n            # Construct PyG Data object\n            g = Data(pos=pos, signal=signal, y=origin_tensor.unsqueeze(0))  # y shape (1, 2)\n\n            data_list.append(g)\n\n        # Optional transformations\n        if self.pre_transform is not None:\n            data_list = [self.pre_transform(data) for data in data_list]\n            data_list = [add_edge_weight(data) for data in data_list]\n\n        # Save processed data\n        data, slices = self.collate(data_list)\n        torch.save((data, slices), self.processed_paths[0])","visibility":"show","key":"JDTV31cD6k"},{"type":"outputs","id":"xucmaJjSRaeZz152VpZtS","children":[],"visibility":"show","key":"DYQZnkrXEo"}],"visibility":"show","key":"DPwaNmhwV6"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"raw_dataset = SinOriginDataset_v2(root=\"./sin_train_v2\", pre_transform=KNNGraph(k=5, loop=False, force_undirected=True), \n                       nb_graph=NB_GRAPHS)\nraw_dataset","visibility":"show","key":"feSupmw4p5"},{"type":"outputs","id":"XZ71MUaPHsbbE9WeV8U8A","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"Processing...\nDone!\n"},"children":[],"key":"a9NutfTwMp"},{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":86,"metadata":{},"data":{"text/plain":{"content":"SinOriginDataset_v2(1000)","content_type":"text/plain"}}},"children":[],"key":"Vlun2aQ0o2"}],"visibility":"show","key":"ls41KHIasy"}],"visibility":"show","key":"b1oNFT9Qtv"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = raw_dataset[0]\ndata","visibility":"show","key":"nBd0fVphAJ"},{"type":"outputs","id":"C6Zhb4l1unX8-7l4kVpuL","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":87,"metadata":{},"data":{"text/plain":{"content":"Data(y=[1, 2], pos=[22, 2], signal=[22, 20], edge_index=[2, 140], edge_weight=[140, 2])","content_type":"text/plain"}}},"children":[],"key":"vg3eD14pLT"}],"visibility":"show","key":"p3kYmWlTcZ"}],"visibility":"show","key":"WUZMJyJzD4"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"visualize_graph_torch(data, color='signal')","visibility":"show","key":"rkmVwkQ0cq"},{"type":"outputs","id":"zPzXsfM1rJ95mtHwnXOJb","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"6ef4ac24eb3217bb16652ea26dfe59ff","path":"/6ef4ac24eb3217bb16652ea26dfe59ff.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"RyBKcNJevi"}],"visibility":"show","key":"UeCaP0pyR2"}],"visibility":"show","key":"fPj2AiSfRf"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"plot_signals_subplots_by_distance(data)","key":"AWP4HyvS7m"},{"type":"outputs","id":"eUWLdYxh9iA3rdoyupp1S","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"2a33c3a1b0d36402ea901ac7655f81b7","path":"/2a33c3a1b0d36402ea901ac7655f81b7.png"},"text/plain":{"content":"<Figure size 1000x4400 with 22 Axes>","content_type":"text/plain"}}},"children":[],"key":"MwBCy6VoMq"}],"key":"lGAT8QmFHE"}],"key":"B7Rtwq7S3W"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Preprocessing","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"uuJEswteNf"}],"identifier":"preprocessing","label":"Preprocessing","html_id":"preprocessing","implicit":true,"key":"sOvMJnbmAX"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Normalization of output step, input is already -1 to 1","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"EzCmYjXQ4A"}],"key":"w8QCRUqxPT"}],"key":"XpLKba4dtH"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"class NormalizeTargetsWrapper(torch.utils.data.Dataset):\n    \"\"\"\n    Wraps a PyG dataset to normalize `y` from [min_val, max_val] → [-1, 1].\n    \"\"\"\n    def __init__(self, dataset, min_val, max_val):\n        self.dataset = dataset\n        self.min_val = min_val\n        self.max_val = max_val\n\n    def __len__(self):\n        return len(self.dataset)\n\n    def __getitem__(self, idx):\n        data = self.dataset[idx].clone()\n        # scale from [min, max] to [-1, 1]\n        data.y = 2 * (data.y - self.min_val) / (self.max_val - self.min_val) - 1\n        return data\n\n    def denormalize(self, norm_y):\n        # scale back from [-1, 1] to [min, max]\n        return 0.5 * (norm_y + 1) * (self.max_val - self.min_val) + self.min_val","key":"qS0KILFcdq"},{"type":"outputs","id":"SpFhVKE-lB2mWbmC6yL12","children":[],"key":"g7K1lkjHLi"}],"key":"UPqulsguho"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"normalized_dataset = NormalizeTargetsWrapper(raw_dataset, min_val=0, max_val=6)","key":"RKMm8nCbWD"},{"type":"outputs","id":"oJ3vRliq36IqzhdXc_dsZ","children":[],"key":"RGapKPxL4E"}],"key":"VLFkvmGc5j"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Build the GNN","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"GchlSgJf0M"}],"identifier":"build-the-gnn","label":"Build the GNN","html_id":"build-the-gnn","implicit":true,"key":"fwXILOfyDx"}],"key":"GmZRSrTMnZ"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class MLPNet(torch.nn.Module):\n    \"\"\"\n    GNN model with MLP → 2x GATv2Conv → MLP for graph-level origin prediction.\n\n    Args:\n        channels_x (int): Positional input features per node.\n        channels_y (int): Signal features per node.\n        hidden_channels (int): Hidden dimension.\n        dropout (float): Dropout probability.\n        self_loops (bool): Whether to add self-loops to GATv2Conv.\n\n    Output:\n        Tensor of shape (batch_size, 2), normalized origin coordinates (in [-1, 1]).\n    \"\"\"\n    def __init__(self, channels_x, channels_y, hidden_channels=128, dropout=0.3, self_loops=True):\n        super(MLPNet, self).__init__()\n        torch.manual_seed(1234)\n\n        self.mlp_in = MLP([channels_x + channels_y, 64, hidden_channels])\n\n        self.conv1 = GATv2Conv(\n            in_channels=hidden_channels,\n            out_channels=hidden_channels,\n            heads=2,\n            edge_dim=2,\n            add_self_loops=self_loops,\n            concat=True\n        )\n\n        self.conv2 = GATv2Conv(\n            in_channels=hidden_channels * 2,  # output of conv1 with 2 heads\n            out_channels=hidden_channels,\n            heads=2,\n            edge_dim=2,\n            add_self_loops=self_loops,\n            concat=True\n        )\n\n        self.mlp_out = MLP([hidden_channels * 2, 64], act=nn.LeakyReLU(), dropout=dropout)\n        self.out_linear = Linear(64, 2)\n\n    def forward(self, pos, signal, edge_index, edge_weight, batch=None):\n        x = torch.cat([pos, signal], dim=-1)\n        x = self.mlp_in(x)\n        x = self.conv1(x, edge_index, edge_weight)\n        x = self.conv2(x, edge_index, edge_weight)\n        x = self.mlp_out(x)\n\n        if batch is None:\n            batch = torch.zeros(x.size(0), dtype=torch.long, device=x.device)\n\n        graph_repr = global_mean_pool(x, batch)\n        return self.out_linear(graph_repr).tanh()","visibility":"show","key":"xGKpTTm3MN"},{"type":"outputs","id":"hh-6TmbCBv6jcIL7rW0LY","children":[],"visibility":"show","key":"TBbT78OA5N"}],"visibility":"show","key":"DImpcTROlL"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"training","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"NuqT4IESuV"}],"identifier":"training","label":"training","html_id":"training","implicit":true,"key":"sc73vF4Hig"}],"key":"oCoRmDys05"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"from torch_geometric.loader import DataLoader\nfrom sklearn.model_selection import train_test_split\n\ntrain_dataset, val_dataset = train_test_split(normalized_dataset, train_size=0.8, random_state=42)\nval_dataset, test_dataset = train_test_split(val_dataset, train_size=0.8, random_state=42)\n\ntrain_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)\nval_loader = DataLoader(val_dataset, batch_size=64, shuffle=False)\ntest_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)\n\n\nprint(f\"nb graph train ds= {len(train_dataset)}, nb graph val ds= {len(val_dataset)}, nb graph test ds= {len(test_dataset)}\")","visibility":"show","key":"fuIjOwpvcZ"},{"type":"outputs","id":"AMZQP2ovpCvRZIHMLadDE","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"nb graph train ds= 800, nb graph val ds= 160, nb graph test ds= 40\n"},"children":[],"key":"uE6gx2ajf9"}],"visibility":"show","key":"TtoKrvmJLD"}],"visibility":"show","key":"NyQgKPogU3"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = train_dataset[0]\ndata","visibility":"show","key":"ADcqf2Ak4K"},{"type":"outputs","id":"dbMUWs_d4a_KFMyYLIXid","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":94,"metadata":{},"data":{"text/plain":{"content":"Data(y=[1, 2], pos=[24, 2], signal=[24, 20], edge_index=[2, 152], edge_weight=[152, 2])","content_type":"text/plain"}}},"children":[],"key":"bQG5IBWJ3s"}],"visibility":"show","key":"jmMjSkUiKJ"}],"visibility":"show","key":"sajKCwtjfz"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"for batch in train_loader:\n    print(batch.y.shape)  # Should be [batch_size, 2]\n    break","key":"QEQMTjm2YH"},{"type":"outputs","id":"EMXpbVqu-Q3W5Ozud2J2K","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"torch.Size([64, 2])\n"},"children":[],"key":"KS1TOhj2Jz"}],"key":"ypBiVyDRAc"}],"key":"ZFEbWkAtGk"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"class EarlyStopper:\n    \"\"\"\n    A class for early stopping the training process when the validation loss stops improving.\n    \"\"\"\n    def __init__(self, patience=1, min_delta=0):\n        self.patience = patience\n        self.min_delta = min_delta\n        self.counter = 0\n        self.min_validation_loss = np.inf\n\n    def early_stop(self, validation_loss):\n        if validation_loss < self.min_validation_loss:\n            self.min_validation_loss = validation_loss\n            self.counter = 0\n        elif validation_loss > (self.min_validation_loss + self.min_delta):\n            self.counter += 1\n            if self.counter >= self.patience:\n                return True\n        return False\n\n\ndef train(dataloader, device):\n    model.train()\n    mean_loss = 0\n    for data in dataloader:\n        data = data.to(device)\n        optimizer.zero_grad()\n\n        # Forward pass\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)  # → shape [num_graphs, 2]\n\n        # Check shape of target\n        assert data.y.shape == pred.shape, f\"Expected y shape {pred.shape}, got {data.y.shape}\"\n\n        loss = criterion(pred, data.y)\n        loss.backward()\n        optimizer.step()\n        mean_loss += loss.item()\n    return mean_loss / len(dataloader)\n\n\n@torch.no_grad()\ndef validation(dataloader, device):\n    model.eval()\n    total_loss = 0\n    for data in dataloader:\n        data = data.to(device)\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)\n        loss = criterion(pred, data.y)\n        total_loss += loss.item()\n    return total_loss / len(dataloader)","visibility":"show","key":"Nqq92BNBpq"},{"type":"outputs","id":"lQ4cR-M5JlDk2PZuLbjUF","children":[],"visibility":"show","key":"dPJIxPR8Dc"}],"visibility":"show","key":"bPspNDrPG4"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":4,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"set training parameters","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"wdEDkUYJPo"}],"identifier":"set-training-parameters","label":"set training parameters","html_id":"set-training-parameters","implicit":true,"key":"jBSE2g1C3t"}],"key":"UDOQGklSyA"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n\nmodel = MLPNet(data.pos.shape[1], data.signal.shape[1], hidden_channels=64)\n\ncriterion = torch.nn.MSELoss()  # Define loss criterion.\noptimizer = torch.optim.Adam(model.parameters(), lr=0.0001)  # Define optimizer.\nearly_stopper = EarlyStopper(patience=20, min_delta=0.0)\nprint(device)","visibility":"show","key":"xZ1iFHp7w1"},{"type":"outputs","id":"0h674E0Da7lHioOFcd4sn","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"cpu\n"},"children":[],"key":"aNbdH03rYd"}],"visibility":"show","key":"VbL8E7wWEP"}],"visibility":"show","key":"GG0mWvYBU7"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"model","key":"bgnifaAcKC"},{"type":"outputs","id":"_OVA5dFQhAzp9hUgVvwwe","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":98,"metadata":{},"data":{"text/plain":{"content":"MLPNet(\n  (mlp_in): MLP(22, 64, 64)\n  (conv1): GATv2Conv(64, 64, heads=2)\n  (conv2): GATv2Conv(128, 64, heads=2)\n  (mlp_out): MLP(128, 64)\n  (out_linear): Linear(in_features=64, out_features=2, bias=True)\n)","content_type":"text/plain"}}},"children":[],"key":"o4lUblLarM"}],"key":"uYhLdzkSh2"}],"key":"dh4tEWYBKl"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import time\nloss_train = []\nloss_val = []\nbest_loss = 1\nbest_epoch = 0\nPATH_CHECKPOINT = \"./checkpoint/best_origin_pred.pt\"\nstart_time = time.perf_counter()\n\nnb_epoch = tqdm(range(5000))\n\nfor epoch in nb_epoch:\n    loss_train.append(train(train_loader, device))\n    loss_val.append(validation(val_loader, device))\n    \n    if loss_val[-1] < best_loss:\n        best_loss = loss_val[-1]\n        best_epoch = epoch\n        torch.save(model.state_dict(), PATH_CHECKPOINT)\n    if early_stopper.early_stop(loss_val[-1]):\n        print(f\"early stopping at epoch {epoch}: train loss={loss_train[-1]}, val loss={loss_val[-1]}\")\n        break\n    nb_epoch.set_postfix_str(f\"train loss={loss_train[-1]}, val loss={loss_val[-1]}\")","visibility":"show","key":"WtwCdSkNVJ"},{"type":"outputs","id":"1b0T98rRM1eSWz8Eljowk","children":[{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"  7%|█▏              | 372/5000 [04:48<59:45,  1.29it/s, train loss=0.007162592015587366, val loss=0.01536410798629125]"},"children":[],"key":"YDXjyWnRdY"},{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"early stopping at epoch 372: train loss=0.007230119385684912, val loss=0.015283139422535896\n"},"children":[],"key":"zTDvwWjSlS"},{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"\n"},"children":[],"key":"AAWk4q6LpZ"}],"visibility":"show","key":"zHgP1A3Gep"}],"visibility":"show","key":"tLHbdNkU02"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# restore best model\n# PATH_CHECKPOINT = \"./checkpoint/best_origin_pred.pt\"\nmodel.load_state_dict(torch.load(PATH_CHECKPOINT))\nprint(f\"best loss={best_loss}, model eval loss={validation(test_dataset, device)} at epoch {best_epoch}\")","visibility":"show","key":"m8ZU6XmXPO"},{"type":"outputs","id":"EJMWugf8cj0t2c2CfZmP8","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"best loss=0.01510655228048563, model eval loss=0.015202970179961995 at epoch 352\n"},"children":[],"key":"auNtRwohp4"}],"visibility":"show","key":"aYIQHtbNL2"}],"visibility":"show","key":"AzcrxpUVmU"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"data = test_dataset[0]\nmodel = model.to('cpu')\npred = model(data.pos, data.signal, data.edge_index, data.edge_weight).detach()\npred.shape","visibility":"show","key":"fOEqMXiefI"},{"type":"outputs","id":"wYL4L6NhToVRuI6t_bRmi","children":[{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":101,"metadata":{},"data":{"text/plain":{"content":"torch.Size([1, 2])","content_type":"text/plain"}}},"children":[],"key":"llZYMFdtmJ"}],"visibility":"show","key":"fviBGHv1Ha"}],"visibility":"show","key":"LP9KaZYDmg"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"print(f\"target={data.y}, pred={pred}\")","key":"AYCcFrchWg"},{"type":"outputs","id":"I3zjYVohTD6BTVIc-UAXV","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"target=tensor([[-1.0000, -0.6667]]), pred=tensor([[-0.8696, -0.4421]])\n"},"children":[],"key":"nXj5I3lN2a"}],"key":"aonTLdZARj"}],"key":"CdyoTehQ1H"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Get the first 10 graphs from the dataset\nfor i in range(10):\n    data = test_dataset[i].clone()  # or normalized_dataset[i] if wrapped\n    data = data.to(device)\n\n    # Run prediction\n    with torch.no_grad():\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, batch=None)\n\n    # Denormalize\n    data.pred = normalized_dataset.denormalize(pred)  # model output\n    data.y = normalized_dataset.denormalize(data.y)  # true origin\n\n    # Optional: error vector for color\n    data.error = torch.norm(data.pred - data.y, dim=-1).unsqueeze(0)  # shape [1]\n\n    # Visualize\n    visualize_graph_torch(data, color=\"signal\", pred=True)","key":"iqOigXNYH8"},{"type":"outputs","id":"MbYVV99z0t7uIyyKNaafF","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"f6be4a54d4f5a96a5ab1471ea4a11c5c","path":"/f6be4a54d4f5a96a5ab1471ea4a11c5c.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"nPrHnv1AMT"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"03b88a7db81bfb6ad30999e1f41df94e","path":"/03b88a7db81bfb6ad30999e1f41df94e.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"iCLGmH7k85"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"e91c6352493a12627d9fb55fd690c06f","path":"/e91c6352493a12627d9fb55fd690c06f.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"JJzB66MSc3"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"b8d6316b36b3e6f77512bc88faac7b66","path":"/b8d6316b36b3e6f77512bc88faac7b66.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"C2rI6WWpd6"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"cc4bdc6ecc3b58d00952e9fc9af7d4aa","path":"/cc4bdc6ecc3b58d00952e9fc9af7d4aa.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"yxIXLwBKuF"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"9b26249eba49a319ade34af6877e6a75","path":"/9b26249eba49a319ade34af6877e6a75.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"cILwLxKL1t"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"6eb41100e3cc1c69c35d9521258f60bc","path":"/6eb41100e3cc1c69c35d9521258f60bc.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"zjFMdJejWY"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"ac3c047095cea5456834f04dd4556719","path":"/ac3c047095cea5456834f04dd4556719.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"jFcgkKCUMe"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"007fa37c0ad5c4298a8698e019d3585f","path":"/007fa37c0ad5c4298a8698e019d3585f.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"mfBg3U903l"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"f405da987b4afb989f52c7bdfd0ec415","path":"/f405da987b4afb989f52c7bdfd0ec415.png"},"text/plain":{"content":"<Figure size 600x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"WLPDENzHiF"}],"key":"JaJkToqQ2l"}],"key":"GFoxOSu6Ed"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"plt.plot(loss_train, label=\"Train\")\nplt.plot(loss_val, label = \"Validation\")\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.5))","visibility":"show","key":"Hil8rhjxad"},{"type":"outputs","id":"WcYuwE05e0D8bWwQglyiM","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"e257b74cf322da05171d95f7dbdbd322","path":"/e257b74cf322da05171d95f7dbdbd322.png"},"text/plain":{"content":"<Figure size 640x480 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"FJvapwFrlF"}],"visibility":"show","key":"xHQghcI9EE"}],"visibility":"show","key":"iPvwQ1P3tF"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"location error","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"P2BwHjXEmZ"}],"identifier":"location-error","label":"location error","html_id":"location-error","implicit":true,"key":"bIG4ReXJBQ"}],"key":"X6pMr9GGBh"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"@torch.no_grad()\ndef evaluate(model, test_loader, normalized_dataset, device):\n    \"\"\"\n    Evaluate model on full test set and compute average error in x and y.\n\n    Args:\n        model: Trained model\n        test_loader: DataLoader for the test set\n        normalized_dataset: NormalizeTargetsWrapper instance (for denormalization)\n        device: torch.device\n\n    Returns:\n        avg_error_x, avg_error_y\n    \"\"\"\n    model.eval()\n\n    pred_all = []\n    true_all = []\n\n    for data in test_loader:\n        data = data.to(device)\n        pred = model(data.pos, data.signal, data.edge_index, data.edge_weight, data.batch)\n\n        # Denormalize both prediction and target\n        pred_denorm = normalized_dataset.denormalize(pred)\n        true_denorm = normalized_dataset.denormalize(data.y)\n\n        pred_all.append(pred_denorm.cpu())\n        true_all.append(true_denorm.cpu())\n\n    # Stack all predictions and truths\n    pred_all = torch.cat(pred_all, dim=0)  # shape [num_graphs, 2]\n    true_all = torch.cat(true_all, dim=0)  # shape [num_graphs, 2]\n\n    # Compute absolute errors\n    abs_errors = torch.abs(pred_all - true_all)  # shape [num_graphs, 2]\n    avg_error_x = abs_errors[:, 0].mean().item()\n    avg_error_y = abs_errors[:, 1].mean().item()\n\n    print(f\"Average Error — X: {avg_error_x:.3f}, Y: {avg_error_y:.3f}\")\n    return avg_error_x, avg_error_y","key":"xRr98ZCmAP"},{"type":"outputs","id":"4KAhCdxD4PlRTX5icKW7u","children":[],"key":"KafubvZC0J"}],"key":"mG4waSfPvW"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"arror_x, error_y = evaluate(model, test_loader, normalized_dataset, device)","key":"SQvVcOZvR4"},{"type":"outputs","id":"qllekLKchv5X6L3esrfEO","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"Average Error — X: 0.262, Y: 0.329\n"},"children":[],"key":"ycw94kXVXj"}],"key":"vqxXs23tGV"}],"key":"SyBbxVNiLe"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":4,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Saving results","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"FJTPLSnJpY"}],"identifier":"saving-results","label":"Saving results","html_id":"saving-results","implicit":true,"key":"TMSdMopmfa"},{"type":"heading","depth":5,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"one dist","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"nRfKIm7Iy5"}],"identifier":"one-dist","label":"one dist","html_id":"one-dist","implicit":true,"key":"q0eGqkADru"},{"type":"paragraph","position":{"start":{"line":4,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"2 GAT layers X: 0.412, Y: 0.420\n1 GAT layer X: 0.382, Y: 0.374","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"vmuSQeujU0"}],"key":"MCS5hUogkO"},{"type":"heading","depth":5,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"dist x and y","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"IdsrDtqNG7"}],"identifier":"dist-x-and-y","label":"dist x and y","html_id":"dist-x-and-y","implicit":true,"key":"kv8tlOSzUk"},{"type":"paragraph","position":{"start":{"line":8,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"1 GAT layer X: 0.367, Y: 0.446\n2 GAT layer X: 0.412, Y: 0.343\n2 GAT layer + self-loop","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"SVBvvYzBxT"}],"key":"gGR2MRELzY"}],"key":"FLm5ApUwHL"}],"key":"BbR5YjU1co"},"references":{"cite":{"order":[],"data":{}}}}